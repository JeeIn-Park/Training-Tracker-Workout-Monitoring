\TODO : deal with  Critical (or Showstopper) Errors


version code change


In the competitive landscape of mobile applications, user satisfaction and engagement are paramount. To enhance my app, I actively incorporated user feedback, aiming to create a more intuitive and engaging user experience by addressing their needs and expectations. User feedback identified pain points and areas of friction, enabling me to remove barriers and improve satisfaction while reducing churn rates. By continuously evolving my app based on real-world usage, I ensure it stays relevant and competitive. User suggestions inspired innovative features, differentiating my app and providing unique value. Engaging with users and implementing their feedback fostered community and trust, increasing loyalty and positive word-of-mouth. This data-driven approach ensured that my development priorities aligned with actual user needs, leading to effective updates. Improving my app based on user feedback was a strategic decision to deepen my connection with users, enhance functionality, and ensure sustained growth and success. This report details the steps I took, the feedback received, and the tangible improvements made, reflecting my commitment to continuous improvement and user satisfaction.
\TODO : add this will help me acheive the project aim.

\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

% generate paragraphs from the data I give you : among feedbacks and error reports I got from app users, 
% there were reports on errors related to High (or Major) Errors.
% I prioritied fixing these error. 
% After this fixage of error, the app was re-released.
% this was for better feedback data collection,
% as these error made my app unsuable for several users.

Among the feedback and error reports I received from app users, there were several reports highlighting High (or Major) Errors. These errors significantly impacted the app's functionality, making it unusable for several users. Recognizing the severity of these issues, I prioritized fixing these critical errors. After addressing and resolving the major bugs, the app was re-released. This re-release aimed to provide a more stable and reliable user experience, facilitating better further feedback data collection. 
Alongside with releasing version 2.1, with app download link, I also added google feedback form for app version 2.1 on github for even better facilitating on feedback collection. User could simply click on the link to download the app, and easily leave the detailed review on the app.   


% app crashes report : when entering setting screen, error generated. (from 3 people)
% inspect the code based on users' description, found this happens when users' phone is one darkmode.
% This was because the setting fragment's layout was using colour from the theme, with attr. 
% As this colour was not defined on dark mode's theme(in app/src/main/res/values-night), the issue generated.  
% -> dark mode adjustment by implementing dark mode theme colours. 

I received multiple app crash reports specifically related to the settings screen, with three users indicating that an error was generated upon entering this screen. Upon inspecting the code based on the users' descriptions, I identified that these crashes occurred when the users' phones were in dark mode. The issue was rooted in the settings fragment's layout, which utilized colors from the app's theme using attributes. However, these colors were not defined in the dark mode theme, located in app/src/main/res/values-night. Consequently, the absence of these color definitions in dark mode caused the app to crash. To address this problem, I implemented dark mode adjustments by defining the necessary theme colors for dark mode. This solution ensured that the settings screen would handle color resources correctly, regardless of the mode, thereby preventing further crashes.

% Another major error was that users couldn't add exercise cards by clicking the floating action button. as it doesn't work (Got this report from two people)
% when click the button, the app doesn't direct users to the add card activity.
% In an Android application featuring a home screen with interactive elements, a significant user interface problem was identified where the Floating Action Button (FAB) did not respond consistently to user clicks. This button, crucial for initiating actions like adding new cards or logging activities, failed to trigger transitions to other activities, significantly impairing the user experience. 

% Upon investigation, the root of the problem was traced back to the mishandling of touch events within the `setupDraggableFAB` method in the `HomeFragment` class. The original implementation did not adequately distinguish between drag gestures and simple taps. As a result, even slight movements during what was meant to be a tap were incorrectly processed as drags, preventing the execution of the intended click events.

% To address this issue, a boolean flag `isDrag` was introduced in the updated implementation of the FAB's touch handling logic. This flag is used to distinctly track whether the user's interaction with the button is a drag or a tap. During the touch event handling, movements that exceed a minimal threshold are classified as drags (setting `isDrag` to true), distinguishing them from taps. The `MotionEvent.ACTION_UP` event then checks the status of `isDrag`. If false, indicating that the interaction was a tap and not a drag, the `performClick()` method is executed to carry out the button’s action. Conversely, if true, it finalizes the position of the FAB based on the drag but does not trigger a click.

% The implementation of this solution effectively resolved the problem, ensuring that taps are correctly recognized and handled as such. The FAB now reliably responds to user interactions, whether they are drags to reposition the button or taps to perform an action. This correction has significantly improved the usability of the application, ensuring that the FAB performs its critical role in the user interface without frustrating users with unresponsive behavior.

Another major error reported by users was that they couldn't add exercise cards by clicking the Floating Action Button (FAB). Specifically, two users noted that clicking the button did not direct them to the add card activity. This issue significantly impaired the user experience, as the FAB is crucial for initiating actions like adding new cards or logging activities.

Upon investigation, the root of the problem was traced back to the mishandling of touch events within the `setupDraggableFAB` method in the `HomeFragment` class. The original implementation did not adequately distinguish between drag gestures and simple taps. As a result, even slight movements during what was meant to be a tap were incorrectly processed as drags, preventing the execution of the intended click events.

To address this issue, I introduced a boolean flag `isDrag` in the updated implementation of the FAB's touch handling logic. This flag is used to distinctly track whether the user's interaction with the button is a drag or a tap. During the touch event handling, movements that exceed a minimal threshold are classified as drags, setting `isDrag` to true, distinguishing them from taps. The `MotionEvent.ACTION_UP` event then checks the status of `isDrag`. If false, indicating that the interaction was a tap and not a drag, the `performClick()` method is executed to carry out the button’s action. Conversely, if true, it finalizes the position of the FAB based on the drag but does not trigger a click.

The implementation of this solution effectively resolved the problem, ensuring that taps are correctly recognized and handled as such. The FAB now reliably responds to user interactions, whether they are drags to reposition the button or taps to perform an action. This correction has significantly improved the usability of the application, ensuring that the FAB performs its critical role in the user interface without frustrating users with unresponsive behavior.



\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\



---

Among the feedback and error reports I received from app users, there were several reports highlighting High (or Major) Errors. These errors significantly impacted the app's functionality, making it unusable for several users. Recognizing the severity of these issues, I prioritized fixing these critical errors. After addressing and resolving the major bugs, the app was re-released. This re-release aimed to provide a more stable and reliable user experience, facilitating better further feedback data collection.

One specific issue reported by three users was that the app crashed when entering the settings screen. Upon inspecting the code based on the users' descriptions, I identified that these crashes occurred when the users' phones were in dark mode. The issue was rooted in the settings fragment's layout, which utilized colors from the app's theme using attributes. However, these colors were not defined in the dark mode theme, located in app/src/main/res/values-night. Consequently, the absence of these color definitions in dark mode caused the app to crash. To address this problem, I implemented dark mode adjustments by defining the necessary theme colors for dark mode. This solution ensured that the settings screen would handle color resources correctly, regardless of the mode, thereby preventing further crashes.

Another major error was reported by two users who found that they couldn't add exercise cards by clicking the Floating Action Button (FAB). When clicking the button, the app did not direct users to the add card activity, significantly impairing the user experience. In an Android application featuring a home screen with interactive elements, this button, crucial for initiating actions like adding new cards or logging activities, failed to trigger transitions to other activities. This button, crucial for initiating actions like adding new cards or logging activities, failed to trigger transitions to other activities, significantly impairing the user experience. 

Upon investigation, the root of the problem was traced back to the mishandling of touch events within the `setupDraggableFAB` method in the `HomeFragment` class. The original implementation did not adequately distinguish between drag gestures and simple taps. As a result, even slight movements during what was meant to be a tap were incorrectly processed as drags, preventing the execution of the intended click events. To address this issue, a boolean flag `isDrag` was introduced in the updated implementation of the FAB's touch handling logic. This flag is used to distinctly track whether the user's interaction with the button is a drag or a tap. During the touch event handling, movements that exceed a minimal threshold are classified as drags (setting `isDrag` to true), distinguishing them from taps. The `MotionEvent.ACTION_UP` event then checks the status of `isDrag`. If false, indicating that the interaction was a tap and not a drag, the `performClick()` method is executed to carry out the button’s action. Conversely, if true, it finalizes the position of the FAB based on the drag but does not trigger a click. The implementation of this solution effectively resolved the problem, ensuring that taps are correctly recognized and handled as such. The FAB now reliably responds to user interactions, whether they are drags to reposition the button or taps to perform an action. This correction has significantly improved the usability of the application, ensuring that the FAB performs its critical role in the user interface without frustrating users with unresponsive behavior.

Alongside the release of version 2.1, I added a Google feedback form for app version 2.1 on GitHub to facilitate better feedback collection. Users could simply click on the link to download the app and easily leave detailed reviews. This streamlined the process for collecting user feedback, enabling continuous improvements and ensuring the app met users' needs more effectively.

---

Among the issues reported and the feedback submitted, I was able to identify some High (or Major) Errors. These errors were really crippling the app's functionality, making the app virtually unusable for some users. Realising the critical nature of the bug fixes, I made those bug fixes my priority. After fixing major bugs, the app was re-released. The purpose of the re-release is to be more stable and reliable for the user in the provision of better further feedback data collection.

One major bug that all three users reported was the crash on entering the settings screen. From the users' descriptions and the source code, I identified that the crash was a result of the phones of the three users being in dark mode. It was therefore identified that in the layout for the settings fragment, colours were being pulled from the application's theme using attributes. The app/src/main/res/values-night dark mode theme was missing colour definitions, so the app would crash. The definitions of the needed theme colours for dark mode fixed the dark mode adjustments. This fixed the settings screen in handling the colour resources no matter the mode, thus preventing further crashes.

The other important error took place when the users reported being unable to add exercise cards by clicking the Floating Action Button (FAB). The app does not send the user to the add card activity in any way, which reduces the user experience. An Android application having a home screen with interactive elements needs a FAB in order to perform activities like adding new cards or, in this case, logging activities. It performed poorly since it didn't instruct the user to the addition card activity when clicked, therefore reducing user experience.

Further inspection has found that the problem lay in the mishandling of touch events in the setupDraggableFAB method in the HomeFragment class. In the initial implementation, it did not clearly differentiate between drag gestures and simple taps. Consequently, even the slightest movement during the supposed tap was mistakenly taken as a drag, and click events were not taking place. The latest implementation of touch handling logic for the FAB that has been introduced is a boolean flag isDrag. Thus, the flag is used to track distinctly whether the user's interaction with the button is a drag or a tap. On the other hand, if events are greater than a minimum threshold, then, during the handling of the touch event, it will be taken as a drag because of the set value of isDrag, which distinguishes a tap from a drag. Next, on the MotionEvent.ACTION\_UP event, inspection on the isDrag value is then made. If it is false, it means the interaction was a tap and not a drag, hence the method performClick() is executed to finish the action of the button. Else, this ensures the FAB position after the drag and does not complete a click. This was instrumental in fixing the problem, as taps should now be properly tracked and registered as such. The FAB now works properly by responding to drags for repositioning or responding to a tap for action. This greatly enhanced the usability of the application in ensuring that the FAB played its critical role on the user interface without frustrating the user with unresponsive behaviour. I immediately added a Google feedback form for app version 2.1 to the README on GitHub after its release. The users had to click on the provided link to get the app and leave detailed reviews. The process made it easy, hence allowing constant improvements to better meet the users' needs.

minor error / inconvenience / suggestions report


\TODO : about tag selection and reset technical explanation and detailed implementation


% tag selection reset 
% tag selection is maintained although the user move across the fragments, as it maintains the tag selection on local storage.
% The tag selection maintainess was controlled along main activity's life cycle to enable resetting when user turn off the app, or open another activity.
% So when user turn on the app again or visit fragments containing tag bar again, user can select new tags without de-selecting them manually.  
% However, there was inconvenience reported about tag being resetted after user add exercise logs.
% Since user will want to keep the tag selection while they finish logging throughtout until they finish the app
% To ensure the tag selection is only resetted when user actually turn off the app,
% the app's activity lifecycle needed to be relied on main activity. 
% Turning AddLogActivity and AddCardActivity into fragments, the lifecycle of app can be controlled with the lifecycle of the main activity. 
% In this reason, activities aside from main activity are turned into fragments.
% Rather than intenting the activivty when they need to be triggered, 
% using navigation, it changes the fragment displayed on the main activity.
% With this change, I needed to pass data to the displayed fragment in different way.
% differently than the original way to pass the data which was intent with putextra,
% I used argument passed when the fragment is navigated.
% this navigation function is passed to adapter for dealing with navigation on item clicked.
% Allowing add log activity and add card activity to be fragments serves other benefits as well.
% As user still can use the bottom navigatiom bar while entering a new log or a new exercise card, they can check other fragments while they are entering a new data and come back.
% To enable bottom navigation bar utilisation, I added the addOnDestinationChangedListener on main activity.
% {write about how does it work, but do not include code snippet:         navController.addOnDestinationChangedListener { _, destination, _ ->
% when (destination.id) {
%     // home
%     R.id.navigation_home -> navView.menu.findItem(R.id.navigation_home).isChecked = true
%     R.id.navigation_add_card -> navView.menu.findItem(R.id.navigation_home).isChecked = true
%     R.id.navigation_add_log -> navView.menu.findItem(R.id.navigation_home).isChecked = true

%     // status
%     R.id.navigation_status -> navView.menu.findItem(R.id.navigation_status).isChecked = true

%     // setting
%     R.id.navigation_setting -> navView.menu.findItem(R.id.navigation_setting).isChecked = true
%     R.id.navigation_privacy_policy -> navView.menu.findItem(R.id.navigation_setting).isChecked = true
% }
% }}
% Also, it provides more intuitive navigation via back arrow button on the action bar.
% This was enabled by     @Deprecated("Deprecated in Java")
% override fun onOptionsItemSelected(item: MenuItem): Boolean {
%     when (item.itemId) {
%         android.R.id.home -> {
%             findNavController().navigateUp()
%             return true
%         }
%     }
%     return super.onOptionsItemSelected(item)
% }
% .

The maintenance of tag selection even as users navigate across different fragments was implemented by storing the selections in local storage. This approach ensured that the tag states are preserved throughout the user interactions within the app unless explicitly reset. The reset functionality is closely tied to the lifecycle of the main activity, allowing tag selections to be reset only when the user completely shuts down the app or opens a new activity. This lifecycle management is critical, especially when transitioning from one activity to another within the app.

However, user feedback highlighted a specific issue where tags were being undesirably reset whenever users added exercise logs, disrupting the user flow as they preferred the tags to remain selected throughout their logging activities until they fully exited the app. To address this, significant structural changes were made to the application’s architecture. Primarily, the `AddLogActivity` and `AddCardActivity` were transformed into fragments. This change permitted more granular control over the app’s lifecycle through the main activity, enhancing the consistency of user experience across different components of the app.With the transition to using fragments, the method of data passing had to be rethought. Instead of using intents with `putExtra` for passing data, navigation arguments were employed. This change was facilitated through modifications in the adapter, allowing it to handle navigation based on item clicks effectively. 

The adaptation to fragment-based navigation not only solved the issue of tag resets but also introduced benefits like uninterrupted access to the bottom navigation bar. Users could now navigate to other parts of the app while engaged in tasks such as logging a new exercise, enhancing multitasking within the app.An `addOnDestinationChangedListener` was integrated into the main activity for this. This listener updates the bottom navigation bar's state based on the current destination, ensuring that the appropriate menu item is highlighted. This method provided a smoother and more intuitive user experience, particularly when switching between different sections of the app. Additionally, the handling of the back arrow on the action bar was improved to better manage fragment navigation, using the `navigateUp` method of `NavController` to ensure that users could seamlessly return to previous screens. These enhancements collectively contributed to a more cohesive and user-friendly application, aligning with modern Android development practices focused on robust navigation and lifecycle management.



% other feedbacks indicates the app is not easy to use.
% more specifically, they  said it is difficult to know what components are doing what.
% and some components behaviour don't make intuitive sence.
% to solve this problem effectively, I employed observer pattern. with specialised events publisher notifes the event and subcribers deal with the events. and unsubscribe end of the lifecycle(why? memory leakage?).

The application received critical feedback indicating that users found it difficult to navigate and understand the functionality of its various components. Users pointed out that it was not always clear what each component was designed to do and that some of the behaviors of these components were not intuitively logical. To address these concerns and enhance the app’s usability, an architectural shift towards implementing the observer pattern was adopted.


% Feedback : Adding card and tags are inconvenient. it is difficult to know how to add exercises and tags. Additionally, when add tags, it was confusion to know how to select muscles and tags as there is no button which indicate confirming selection. and why there are two differnt sections for selecting muscles when I can select multiple muscles? also, why do I always need to select tags again when I already selected tags on the home screen? 

% description on how to add tag and exercise is added to the HomeFragment. When there is change on exerciseCard(LiveData) passed, or when the fragment is loaded, the HomeViewModel checks if the list of card to be desplayed is empty or not and publish that state with boolean value. The HomeFragment subscribe this event and it changes the visibility state of description depends on the data which indicate if the cards shown on the recycler view is empty or not.

% Also, on add card fragment, now it detects the selected tags and automatically add it when user add a exercise. this is not only intuitive but also make it easy to add multiple exercises with same tags. I added confirm button on each spinner.also, giving outline on each spinner, I provided more intuitive view on it. ALso, I added which spinner is for what. Also, to make the primary spinner's hint to not be empty for clearer description on spinners, I utilised the SELECT_TAG by resetting it when there is no entered value when user enter add card activity for editing existing card.  


Based on the feedback provided by users about the inconvenience and confusion encountered when adding cards and tags, several enhancements were made to the application to improve the user interface and streamline the interaction process.

The main issue was the difficulty in understanding how to add exercises and tags, coupled with confusion over the selection process for muscles and tags, which lacked a clear confirmation mechanism. Users also expressed frustration over having to reselect tags that had already been chosen on the home screen, and questioned the necessity of having two separate sections for selecting multiple muscles.

To address these issues, the following changes were implemented:

1. **Improved Instructions**: The HomeFragment now includes a description on how to add tags and exercises. This is dynamically displayed based on the state of the exercise cards. When the HomeFragment is loaded, or there is a change in the LiveData representing the exercise cards, the HomeViewModel checks if the list of cards to be displayed is empty. It then publishes a boolean state to indicate this. If the recycler view for cards is empty, the description becomes visible, guiding users through the process of adding new exercises and tags.

2. **Automated Tag Selection**: In the Add Card Fragment, the application now detects tags selected by the user elsewhere in the app and automatically includes these tags when a new exercise is added. This feature removes the redundancy of reselecting tags for each new exercise, streamlining the process of adding multiple exercises with the same tags.

3. **User Interface Enhancements**: Each spinner used for selections now has a confirm button to explicitly finalize choices, addressing the previous lack of clear confirmation cues. Additionally, each spinner has been given an outline and labels to enhance visual clarity and intuitive use. This redesign helps users understand exactly what each spinner is intended for.

4. **Spinner Functionality Improvements**: To prevent confusion from an empty primary spinner when editing an existing card, the `SELECT_TAG` is reset if no value is entered. This ensures that the primary spinner's hint is never empty, providing a clearer description and improving the user's understanding of how to interact with the spinners effectively.

These changes were designed to enhance the clarity of the app's functionality, making it more intuitive and user-friendly. The implementation of clear instructions, automated processes, and visual cues significantly improved the user experience by simplifying the interactions and making the application's operations more transparent and easier to navigate.



\TODO : list adapter for today table and live data update
\TODO : empty set storage null control
\TODO : filter card storage

% Feedback : how do I know today's 1RM? it only can be found when I finish logging session. I want to know today's progress right away. also, I want to continue logging before I finish the session and start logging records on another exercise. I don't want the session to be ended until then. Also, can you make entering records easier? It is annoying to change them again and again for each set as I need to delete them and type them. maybe you can reset it after each set? if there is better way I will appriciate that as well. main problem is that I need to delete and enter it again and again. too much step for just logging one single set.  

% When there is new set added on an exercise's logging session, while storing the set to the local storage, the SetStorage notifies that there has been a set added. AddLogFragment subcribes this event and by passing the sets passed by SetStorage with event to the FormattedStringGetter, it gets the string which can tell user today's best 1rm and display it. this is updated automatically right away whenever user made a new best 1rm record for today's session.

% also continue logging before they actually finish session. 
% storing the current logging status on local storage,
% now the app deals with log data more stably, and also enable to resume the current session when user come back to add log fragment.
% Also the set num is now stored on local storage, as user might continue the session after come back. 
% (originally, it was stored on class attribue, so was initialised whenever they enter the fragment)
% store sets and reset sets when close app

% Logging itself became much easier and convenient as well as the app automatically enters the user's last sessions' first set data. Also, now user don't need to delete and re-enter the value. they can simply change the weight lifted and reps completed just by swiping on them. they only need to re-enter them only when they really want to do it. 
Based on user feedback regarding the functionality of logging workout sessions and specific requests for enhancements to the user interface and interaction processes, several key improvements were implemented to address these concerns effectively.

Users expressed a need to see their progress, specifically today's best one-repetition maximum (1RM), immediately during their workout sessions, rather than only after completing their logging. To accommodate this, the application now utilizes an event-driven approach to update 1RM calculations dynamically. Whenever a new set is added during a logging session and stored to the local storage, the `SetStorage` component triggers a notification event. The `AddLogFragment` subscribes to this event, and upon receiving data about the new set, it passes this information to the `FormattedStringGetter`. This component then calculates and returns a string representing the best 1RM achieved in the current session, which is immediately displayed to the user. This allows users to monitor their strength progress in real-time, enhancing the interactive experience of the workout log.

In response to the feedback regarding the inconvenience of having to delete and re-enter data for each set, the application's logging interface was significantly refined to reduce the steps involved. The app now pre-populates each new set entry with the data from the first set of the user’s last session, facilitating quicker and more efficient logging. Users can adjust the weights lifted and reps completed by simply swiping on the input fields, drastically reducing the need to manually delete and retype information. This streamlined interaction is designed to make logging workouts less tedious and more user-friendly.

Furthermore, to address concerns about session continuity, the application's handling of logging data has been enhanced. Current logging status and set numbers are now saved to local storage, allowing users to pause and resume their sessions seamlessly. This change ensures that users can return to their logging activities without losing progress, even if they switch exercises or temporarily leave the logging interface. This capability provides a more flexible and user-centered approach to tracking workouts, accommodating the varying paces and preferences of users in their workout routines.

These improvements collectively address the main issues highlighted in the feedback, providing a more intuitive, efficient, and user-friendly logging experience. By automating and simplifying data entry and allowing for dynamic updates and flexible session management, the application better serves the needs of its users, promoting a more engaging and satisfactory fitness tracking experience.



% Feedback : I like the customising tags. but I think I found error on it:). I tried to delete the tag but altho the tag was deleted, it was still shown on the exercise cards. similarly, I edited a tag but the tags on cards were not changed. I needed to delete and edit them one by one throughout all exercise cards... also, I was wondering how do I know which exercise has which tags on status screen? is the only way really just check the home screen for each of the exercise???

% Using the TagAdapter, 
% When user make change on tag by seleting edit delete option from long click,
% change all card which contains that tag reflecting the change user made on that tag by TagStorege
% (check if a card contains the tag and make change is handled by TagStorage), and 
% it publishes that there was change made on cards. 
% HomeFragment and StatusFragment subscribe this and when it got it,
% they notify their ViwModel with updateCardRecyclerViewData passing updated cards. 
% Submited new cards will trigger RecyclerViewData.observe(viewLifecycleOwner) to act.
% this will submit new data to the adapter resulting in changed cards desplayed on recycerview.

% make sure make change on tag in cards no matter the tag was selected or not when it got changed,
% using TagFactory, get the selected version of tag. Then as when tag is assigned in an exercise,
% it is stored with isSelected value true,
% it ensures make changes. 

% tags are now displayed on status's exercise information.
% Using FormattedStringGetter, each tag get '#' and displayed. 
Based on your feedback about issues with customizing tags, several enhancements and bug fixes have been implemented to ensure that tag management in the app is intuitive and error-free. 

Initially, you experienced problems where deleted or edited tags continued to appear unchanged on exercise cards. To address this, the `TagAdapter` was upgraded to ensure that any changes made to tags are comprehensively propagated throughout the app. Now, when a tag is edited or deleted through the long-click edit/delete option, `TagStorage` checks all cards that contain the affected tag. If a card contains the tag, `TagStorage` updates it to reflect the changes made by the user. Once these changes are implemented, an event is published to indicate that modifications have been made to the cards.

Both the `HomeFragment` and `StatusFragment` subscribe to these change notifications. Upon receiving a notification, they instruct their respective ViewModels to update the data for the RecyclerView by calling `updateCardRecyclerViewData` with the new, updated cards. The updated cards trigger the `RecyclerViewData.observe(viewLifecycleOwner)` method, which submits the new data to the adapter, resulting in the updated tags being displayed correctly on the RecyclerView.

To ensure that changes to tags are applied regardless of whether the tag was selected at the time of the change, the `TagFactory` is utilized. It retrieves the selected version of the tag, and because each tag assigned to an exercise is stored with an `isSelected` value of true, this mechanism guarantees that the changes are applied consistently across all relevant exercise cards.

Moreover, to improve visibility of which exercises are associated with specific tags, particularly on the status screen, a new feature was introduced. Using the `FormattedStringGetter`, tags are now prefixed with '#' and displayed alongside exercise information on the status screen. This enhancement makes it easier for users to quickly identify the tags associated with each exercise without needing to navigate back to the home screen.

These updates ensure that tag customization is both robust and user-friendly, addressing the issues you encountered and enhancing the overall functionality of tagging within the app. This makes managing and viewing tags more intuitive and less prone to errors, significantly improving the user experience.



% Feedback : I hate the button on the home screen, I can move it, but it always returns to the original place. then what is point of putting in on different place? is it even necessary to make it able to be moved 

% now it stores the final location of the floating button, and restore it when the fragment is loaded. 
% it saves the location each time user moves the button, 
% and for ensuring it stores the last location,
% using onStop, it saves the location once again at the end.
% the location is stored on  android.content.SharedPreferences. 
Addressing your frustration with the home screen button that could be moved but always returned to its original position, significant changes have been made to ensure that the button's position is now persistent across different sessions.

Initially, the design allowed for the button to be moved, presumably to enhance user experience by providing flexibility in the layout. However, without the ability to save the new position permanently, this feature did not meet its intended purpose, causing user dissatisfaction.

To resolve this issue, the functionality of the floating action button has been modified to remember its last location. Now, when you move the button to a new position on the screen, this location is recorded in real-time. The app uses Android's `SharedPreferences` to store this position data. Each time you move the button, its new location is updated in `SharedPreferences`.

Moreover, to ensure the accuracy and permanence of the button's position, the app captures and saves the location once more during the `onStop()` lifecycle method of the fragment. This additional save acts as a fail-safe to confirm the button's position is updated just before the user exits the app or the fragment is no longer visible, addressing any potential issues that might arise if the app unexpectedly shuts down or fails to save during the move.

Upon returning to the home screen or when the fragment is reloaded, the button's position is restored from `SharedPreferences`. This means the button will appear in the last place you moved it to, rather than defaulting back to its original position.

This improvement ensures that the flexibility to move the floating action button is now a truly functional and user-friendly feature, allowing you to customize the layout of your home screen according to your personal preferences and ensuring that these customizations are maintained across sessions.





% while making all these enhancements, I improved some layouts on the app for better user experience as well.
% by arranging elements with vetical LinearLayout, home card provides more stable layout than arrange each element vertically one by one.
% giving padding on tag name enterence, center it on the dialog. It gives better UI.


% privacy policy was specified for UK app release.
% But I changed it to general privacy policy for releasing app.
% For this, I also stopped collecting users' data when user report the error.
% instead of it, I asked user to enter as much detail as possible.

While addressing specific usability and functionality issues, broader enhancements were also made to the application’s layout and privacy policy to improve overall user experience and compliance with privacy standards.

**Layout Improvements:**
To create a more visually appealing and stable user interface, several changes were made to the layout configurations. By employing a vertical LinearLayout, the home cards now present a more structured and cohesive display. This method of arrangement ensures that elements are stacked vertically in a predictable and orderly fashion, which not only enhances the aesthetic appeal but also improves the usability of the interface. Additionally, adjustments were made to the UI elements such as tag name entry dialogs. By adding padding and centering the text input within the dialog, the interface offers a more polished look and feel, making the text input more accessible and visually centered, which contributes to a smoother user interaction.

**Privacy Policy Update:**
With the initial release targeting the UK market, the app featured a privacy policy specific to UK regulations. However, to broaden the app’s reach and ensure it is suitable for a wider audience, the privacy policy was revised to a more general form. This change involved not only adjusting the language and provisions to encompass a broader scope but also modifying how user data is handled. 

In response to privacy concerns and to comply with best practices, the process for collecting data during error reporting was altered. Previously, the app automatically collected data when users reported errors, which could raise privacy issues. To enhance user trust and privacy, this automatic data collection was ceased. Instead, users are now encouraged to provide as much detail as possible manually when reporting issues. This approach respects user privacy while still allowing for the collection of necessary information to address and resolve application errors effectively.

These layout and privacy policy enhancements are part of a continuous effort to refine the app and ensure it not only meets user expectations in terms of functionality but also adheres to high standards of privacy and design aesthetics.





