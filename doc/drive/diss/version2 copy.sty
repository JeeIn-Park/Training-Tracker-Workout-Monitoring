\subsection{Version 2 Implementation: Enhancing Functionality, Scalability, and Maintainability}


\subsubsection{Enhancing Scalability and Maintainability through Centralised Formatting and Structured Data Management}

In the development of my Android application using Kotlin, significant emphasis was placed on enhancing both the scalability and maintainability of the software to ensure efficient performance and ease of future updates. These improvements demonstrate not only technical proficiency in Android development and Kotlin programming but also a strategic approach to software architecture. The use of design patterns such as the factory pattern for data management and centralised control for string formatting are indicative of advanced programming skills and a commitment to creating scalable, maintainable, and robust software applications.

A major advancement in this regard was the introduction of a centralised string formatting mechanism. This mechanism, encapsulated within a class called `FormattedStringGetter`, is crucial for maintaining consistency across the app's user interface. It provides a unified approach to converting data into strings, allowing for uniform presentation and simplification of modifications. By centralising string formatting, any required changes to the data presentation can now be managed in one location, rather than across multiple classes, enhancing the maintainability and reducing the potential for inconsistencies.

Moreover, I significantly improved data management by employing the factory design pattern, a decision that streamlined the instantiation process of data objects throughout the application. This architecture involves factories that are designated to create objects based on predefined data classes. These factories not only enforce a consistent creation process but also simplify the handling of special data cases. By centralising object creation, updates to data classes or their instantiation logic are confined to a single point of modification, thereby increasing the flexibility and scalability of the application.

To further bolster the robustness of the application, I enhanced the data storage and error handling mechanisms. By making the data storage methods private and employing detailed exception handling strategies, the application ensures data integrity and enhances security. These methods are designed to gracefully manage exceptions, providing reliable fallback mechanisms to maintain the application's functionality. This careful management of exceptions and data integrity checks are indicative of high programming standards and a deep understanding of software reliability and user data protection.


\subsubsection{Muscle Status Visualization for Improved Workout Management and Recovery Tracking}
To efficiently manage this feature, I introduced a 'Muscle' class, which acts as a bridge between the muscle vector graphics and the associated muscle status data. This class is instrumental in dynamically updating the displayed colours of the muscle graphics based on their current status. It accomplishes this by comparing the saved muscle data—including names and statuses—with the drawable assets' file names, enabling the app to accurately display the appropriate muscle status for each group. If no data is loaded, the system initialises with default values, setting the 'lastActivity' attribute to null and the initial status to fully recovered, as this process occurs when the user runs the app for the first time, indicating that no workouts have been recorded yet.

The app determines muscle status by comparing the 'lastActivity' timestamp in the muscle data with the current time. Upon each app launch, it refreshes the muscle states by checking the current time and applying a logical algorithm to ascertain the muscle's condition. If 'lastActivity' is null (indicating the app is run for the first time), it assigns the current time for further muscle status tracking. If a muscle has not been exercised for more than ten days, the system flags it as needing exercise; if it has been worked out within the last two days, it indicates that the muscle is in recovery. If none of these conditions apply, the muscle is considered fully recovered. Following this update, the status within the muscle data class is adjusted, and the system then links the updated status to the appropriate drawable resource for visual representation.

To further tailor the user experience, the application includes a feature allowing users to customise exercises with any number of associated muscle groups. This customisation is facilitated by a spinner that can select multiple items, ensuring users can specify both main and sub-muscle groups for each exercise log. When an exercise log is entered, the application checks the associated muscle groups and updates their status to 'being recovered', and updates the lastActivity.

\subsubsection{Enhancing User Customisation and Exercise Management through Efficient Tagging and Advanced Filtering Mechanisms}
The initial attempt to implement this feature involved using strings to represent each tag. However, this approach led to several issues, such as the inability to create tags with identical names and difficulties in managing tag properties like colour changes based on their selection status. To address these issues, I developed a more robust solution in my second implementation attempt.

In this version, I designed a dedicated `Tag` data class to provide a clear structure for tag management. Each tag consists of a unique ID, the time it was added, a name, and a boolean value (`isSelected`) indicating whether the tag is selected. This structure enables better handling of tags, ensuring that each tag is distinct and manageable. Additionally, `ADD\_TAG` and `SELECT\_TAG` were added as companion objects within this class to facilitate tag customisation and selection.

The `ADD\_TAG` functionality allows users to add new tags by clicking on the `ADD\_TAG` icon on the tag bar, which is implemented using a horizontal `RecyclerView`. 

The filtering mechanism works by retrieving selected tags from local storage and then filtering exercise cards based on these tags. If a card contains any of the selected tags, it is displayed; otherwise, it is hidden. When no tags are selected, the filter is disabled, and all exercises are shown. The selected tags persist throughout the main activity's lifecycle, ensuring that users do not need to reselect tags when navigating between fragments. This persistence enhances the user experience by maintaining filter settings across the home and status fragments, allowing seamless transitions without losing tag selections.

Tags can be assigned to exercise cards when users add exercises. The `SELECT\_TAG` companion object is used to display a spinner hint, making it the first tag shown in the spinner. Users can select multiple tags using a multi-select spinner, enabling them to assign numerous tags to an exercise as needed. 



\subsubsection{Workout Analysis with 1RM Tracking for Comprehensive Insights and Improved User Engagement}
To facilitate this, I first updated our data structure by adding a `oneRepMax` attribute to the `ExerciseSet` class. Each time a user logs an exercise set, the app automatically calculates the 1RM for that set and assigns it to this new attribute. This calculation is foundational for tracking the maximum strength output across individual sessions. Next, I introduced a `oneRepMax` attribute to the `ExerciseLog` class. After a user completes logging an exercise, the app compares all the 1RM values from the sets entered during that session and records the highest value. This maximum 1RM value per session is crucial as it allows users to see how their strength has evolved from session to session.

Furthermore, I enhanced the `ExerciseCard` class by also integrating the `oneRepMax` attribute. Whenever a new exercise log is saved, the app checks if the 1RM from this log exceeds the current maximum recorded on the corresponding ExerciseCard. If so, it updates the card's 1RM. This feature not only tracks personal bests but also serves as a motivational tool by showcasing users' strength improvements over time.

Initially fixed, I later made this button draggable to optimise screen space usage and minimise obstruction of content. When not actively used, the button becomes semi-transparent and automatically aligns to the screen's edges, thus reducing visual distraction and maximising the available display area for exercise cards.


\subsubsection{Facilitating Direct User Interaction and Optimised Feedback Integration with Communication Tools}

The 'Report Error' and 'Send Feedback' functions are designed to allow users to communicate directly with the development team via email. For this purpose, I set up a specific email account dedicated to the app (trainingtrackermainbox@gmail.com). When users choose to report an error or send feedback, they can fill out their message directly within the app and send it by email. Implementing this required the app to access the internet, which necessitated adding specific permissions to the app's manifest file. The permission `android.permission.INTERNET` is essential to enable the app to open internet connections for sending emails, ensuring that the feedback process is smooth and effective.