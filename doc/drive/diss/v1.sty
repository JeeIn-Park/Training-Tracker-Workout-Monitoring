
\chapter{Introduction}

Many people going to the gym track their workout progress using fitness tracking apps. These apps enable users to monitor their workout progress efficiently. According to Curry D., "Fitness apps generated \$3.58 billion revenue in 2023, a 9.1\% increase on the year prior, and were downloaded over 850 million times, with 368 million users globally" \cite{curry2024}. This substantial growth has led to a significant expansion in the fitness tracking app market.

In 2023, the market was valued at \$1.54 billion and is expected to grow at a compound annual growth rate (CAGR) of 17.7\% from 2024 to 2030 \cite{grandview2023}. Despite the considerable expansion in the global fitness app market, many individuals still utilize tools like Excel for health and fitness purposes. The availability of numerous templates and resources dedicated to this purpose supports this trend. For instance, Microsoft offers various Excel templates specifically designed for tracking diet, exercise, and other health-related activities \cite{microsoft2024}.

The use of quantifiable data in fitness tracking can stimulate users' interest in enhancing their activity levels. Providing tools to track this data supports the maintenance of motivation and commitment to fitness goals, which could lead to improved health outcomes over time \cite{plos2023}. However, these logs primarily focus on quantifiable data.

While tracking my own workout progress, I found it difficult to monitor muscle status. It was almost impossible to track which muscles were used and when each muscle would be recovered. For this, I needed to track when I performed specific exercises, knowing which muscles were involved, and how much time had passed since I last worked on those muscles. This complex orientation on muscle status tracking is essential to avoid injuries by ensuring that muscles are fully recovered before being worked on again. However, people often do not track this information precisely. Moreover, people are likely to overlook which muscles they haven't worked out if they follow their usual routine, which is important to minimize muscle loss.

From this observation, the idea emerged: what if there was an app that combined the advantages of both Excel and training tracking apps while reducing their drawbacks? What if there was an app that could track muscle status automatically from given exercise logs and visually present it for easy tracking? The primary goal of this project is to create an Android application designed to effectively monitor workouts with quantifiable data and visualized muscle status.

\begin{quote}
    
The solid aims of this project are:

\begin{enumerate}
    \item Investigate factors that can extend user engagement and commitment to their physical goals and use this data to create the initial version of the app.
    \item Develop a second version of the application that addresses the possible shortcomings of spreadsheet workout tracking.
    \item Implement the final version of the app based on actual user feedback.
    \item Evaluate the app in terms of efficiency and user satisfaction and demonstrate that the proposed enhancements are beneficial.
\end{enumerate}
\end{quote}

 %TODO: Fitness apps provide robust tools for logging and managing exercise details such as type, duration, intensity, and frequency. This systematic logging helps users track their progress and adjust their fitness routines to better achieve their goals. %TODO : Features that provide visual representations of progress and historical performance data not only support goal-setting but also motivate users by clearly demonstrating their advancements.

\chapter{Background}
\label{chap:technical}
\section{Setting Up the Android Development Environment}

This section explores the choices involved in establishing a robust development environment tailored for crafting Android applications. These choices, covering the programming language, the integrated development environment (IDE), and the version control system, are predicated on their specific features, advantages, and industry-wide acceptance. Emphasizing contemporary software development methodologies, this configuration is integral to fostering high-quality Android application development.

\subsection{Selecting Kotlin as the Development Language}

Since its endorsement by Google in 2017 as the preferred language for Android development, Kotlin has significantly influenced the Android programming landscape. The language offers a blend of features that not only enhance the development experience but also improve application performance and developer productivity. One of the most appreciated benefits of Kotlin is its conciseness, which helps in reducing boilerplate codeâ€”a common issue with Java. This reduction not only improves code readability but also enhances maintainability, allowing developers to manage and update code more efficiently.

Furthermore, Kotlin's seamless interoperability with Java ensures that developers can continue using existing Android libraries and frameworks, facilitating an easy transition from Java to Kotlin. This is complemented by safety features such as null safety and immutability, which are intrinsic to Kotlin and help mitigate common programming errors like null pointer exceptions, thus enhancing application stability. Additionally, Kotlin incorporates modern programming constructs such as lambdas, coroutines for asynchronous programming, and extension functions, which collectively foster a more modern and productive programming environment. Backed by a robust community and comprehensive support resources, Kotlin stands out as a superior choice for new Android development projects, balancing developer efficiency with the robustness of applications.

\subsection{Choosing Android Studio as the IDE}

Android Studio, designed by Google specifically for Android development, is widely recognized as the ideal integrated development environment (IDE) for this purpose. Its comprehensive suite of features is meticulously tailored to meet the needs of Android developers, providing tools that are essential for efficient and effective application development. Among its standout features is the integrated emulator, which simulates a range of devices and Android versions, allowing developers to test applications in a versatile and controlled environment. This capability is critical for ensuring that apps perform well across different devices and configurations.

Additionally, Android Studio is equipped with robust debugging tools that streamline the development process. These tools include an intuitive UI inspector, a network traffic monitor, and integrated logging, all of which are indispensable for diagnosing and resolving issues swiftly. The IDE also enhances productivity through its array of project templates and code generation features, which not only speed up the development process but also promote adherence to Android development best practices. Moreover, the inclusion of performance tools like the Android Profiler allows developers to monitor app performance in real-time, which is crucial for optimizing resource use and improving user experiences. The integration of Gradle for build automation further simplifies the management of app builds and dependencies, enhancing both productivity and project manageability. Collectively, these features make Android Studio a powerful ally in Android app development, offering a seamless and comprehensive development experience.

\subsection{choose API level}
...
% TODO

\subsection{Implementing GitHub for Version Control}

Utilizing a Git repository, particularly through platforms like GitHub, allows for effective management of source code versions and collaboration. By establishing a dedicated repository for the project, developers can track changes, revert to previous versions when necessary, and manage contributions from multiple team members in a coherent and controlled manner. This is crucial for maintaining the integrity and history of the development process, especially in a collaborative environment.


GitHub, leveraging Git for version control, offers a robust platform for managing development projects effectively. It is integral to facilitating collaborative software development, ensuring that project integrity is maintained through meticulous tracking of version history. This platform supports feature branching and the safe merging of updates, which are crucial for teams working simultaneously on different aspects of the same project. By enabling precise control over changes and contributions, GitHub significantly reduces the risks associated with concurrent development.

In addition to version control, GitHub integrates issue tracking within the same environment, streamlining task organization and the management of bugs and feature requests. This feature aids developers in keeping track of outstanding issues, prioritizing them appropriately, and ensuring that nothing critical is overlooked. Furthermore, GitHub Actions extend the platform's capabilities by automating workflows for testing, building, and deploying applications, thereby enhancing efficiency and reducing the likelihood of human error during these critical stages. The platform also supports release management, which simplifies the distribution of updates to end users and maintains historical versions for ongoing support. Overall, adopting GitHub not only boosts team collaboration and code quality but also provides a comprehensive framework for managing the entire software development lifecycle, making it an invaluable tool for developers.


\section{TODO : understanding of android views}

\subsection{RecyclerView}
Introduced by Google, the RecyclerView component efficiently displays data sets in list or grid formats while ensuring smooth scrolling and performance. It recycles the views of elements that are no longer visible, significantly reducing memory use and enhancing performance. Furthermore, RecyclerView supports various animations for actions like adding or removing items, and these animations enhance the UI's interactivity and visual appeal during scroll events.

The layout of each RecyclerView element is managed through an adapter. A subclass of `RecyclerView.Adapter` called `ListAdapter` offers advantages for handling lists, such as built-in diffing logic for more efficient data updates. The `DiffCallback` leverages the `DiffUtil` class to compute differences between old and new lists, ensuring that only modified elements are refreshed, minimizing UI disruptions.

The adapter functionality is implemented by overriding several key functions: `onCreateViewHolder` and `onBindViewHolder`. The `onCreateViewHolder` method inflates an XML layout, which outlines each item's appearance, creating a new ViewHolder to encapsulate these views. This layout is transformed from XML to view objects via a `LayoutInflater`. Data binding occurs in the `onBindViewHolder` method, where data is bound to the views held by the ViewHolder.

The `ViewHolder` inner class exemplifies the ViewHolder pattern in RecyclerView, significantly optimizing UI performance by minimizing redundant calls to the `findViewById()` method. This method is expensive in terms of processing, and by holding references to all dynamically modified views within each item, the ViewHolder enhances efficiency.


\section{design patterns}
\subsection{try-catch}
\subsection{ Model-View-ViewModel Architecture in Android Development }
The Model-View-ViewModel (MVVM) architecture employed for organizing fragment layouts, enhancing application development with its robust framework. The \textbf{Model} serves as the data and logic layer, managing the data along with the rules and calculations, and is generally detached from the user interface (UI). The \textbf{View} constitutes the UI layer, focusing on the display of data and user interactions within the interface. The \textbf{ViewModel} bridges the Model and the View, supplying data in a usable format for the View while managing the necessary logic to adapt the Model's data. MVVM supports seamless data binding between the View and ViewModel, automating UI updates in response to data changes in the ViewModel. This decouples changes in business logic or UI, allowing for UI redesigns within the View without affecting the Model or ViewModel, thereby simplifying code maintenance and enhancing development flexibility and scalability.

Although both the `Fragment` Kotlin class and the `fragment.xml` XML layout file are integral components of the View layer in the Model-View-ViewModel (MVVM) architecture, their functions within this layer are distinct and complementary. The XML layout file acts as a static blueprint that outlines the appearance and placement of UI elements. This declarative setup allows for a clear and organized design layout, independent of dynamic content. Conversely, the Kotlin class serves as the dynamic part of this duo. It not only binds the ViewModel's data to the UI elements defined in the XML file but also manages user interactions and the UI's responsiveness to data changes. This arrangement means that while the XML file specifies the UI structure, the Kotlin class manipulates these elements in real-time, handling the logic, managing the lifecycle of the view, and subscribing to data updates. It retrieves data from the `ViewModel` and updates the UI components, such as lists and text displays, based on LiveData observed from the ViewModel, ensuring that the UI always reflects the most current data state. 

\section{Muscle Physiology and Its Role in Enhancing Fitness Tracking Technologies}

In this software development project, an in-depth understanding of muscle physiology transcends theoretical knowledgeâ€”it becomes a practical tool for designing an advanced fitness app. This app aims to go beyond mere activity tracking; it seeks to elevate user engagement and optimize training outcomes through scientifically backed recommendations. These recommendations will inform workout frequency, intensity, recovery periods, and strength benchmarks, providing a personalized and safe training regimen for users. By integrating physiological principles, the app will not only serve as a sophisticated tracking tool but also as an educational platform that enhances physical well-being and promotes informed exercise choices, setting it apart from simpler market alternatives.


\subsection{Muscle Growth}

Muscle hypertrophy, or growth, is primarily driven by consistent and strategically varied resistance training. Key factors influencing hypertrophy include the frequency of workouts, intensity and volume of exercises, and crucially, adequate recovery times between sessions. Scientifically, muscles require regeneration periods after being stressed, which involves both the repair of muscle fibers and their growth in strength and size. This biological process is the basis for recommending that each muscle group be trained approximately two to three times per week \cite{Schoenfeld2016}. Integrating this knowledge into a fitness app ensures users receive scientifically-backed guidance on how to structure their workouts for maximum efficacy.


\subsection{Muscle Loss}

Conversely, muscle atrophy occurs when there is a prolonged lack of muscle use, and understanding this is just as vital. The rate at which muscles atrophy can begin is startlingâ€”noticeable decreases in muscle mass and strength can occur within just a few weeks of inactivity. This understanding is essential for developing app features that motivate users to maintain regular exercise routines. For example, the app can remind users to engage muscle groups that have not been recently active, thereby utilising physiological data to help prevent atrophy and promote healthier, more active lifestyles.


\subsection{One-Rep Max (1RM)}

Furthermore, the one-rep max (1RM) is a critical metric in strength training, representing the maximum weight an individual can lift in a single repetition for a given exercise. It is a valuable index for setting benchmarks and measuring strength gains over time. Incorporating 1RM calculations into the app provides users with a quantitative tool to set realistic goals and track their progress in strength training, enhancing both motivation and the personalisation of training programs.


\section{About Muscle Visualisation}
... % TODO : benefits of muscle visualisation 
% TODO : comparing to existing apps

% -----------------------------------------------------------------------------

\chapter{Project Execution}
\label{chap:execution}


\section{Initial Release: Emphasising Core Features and Standard
Tracking Capabilities}

I begin by identifying and exploring the factors that affect user engagement in fitness tracking applications. This process has been shown to  position applications for success in a competitive market \cite{Hallsteinsen2008}. By clearly defining these fundamental aspects, developers can prevent feature creepâ€” the inclusion of unnecessary features that do not serve the app's primary purpose.  This focused approach maintains essential functionality, optimises resource allocation, and improves the user experience by making the app more intuitive and easier to navigate \cite{Lieberman2006}.

Then, I am going to employ those factors for my primary version, minimal viable product(MVP) of the app. By focusing on core features, it streamlines the immediate construction phase and prioritizes resources efficiently, reducing time and costs associated with developing more complex features that may not be essential at the early stages. The MVP serves as the foundational build, incorporating only the essential functionalities needed. The MVP implementation ensures that the development process is structured and efficient, setting a solid foundation for future scalability of the application. 


\subsection{Impact Analysis of Key Features in Fitness Apps}

In this section I break down the understanding of the psychology of user engagement into five attributes:[factors from below], which are critical in mobile applications. \cite{Myers2000}. These attributes will provide a basis on which initial design and the development lifecycle can be built. And then I will analyse fitness tracking apps' features respect to these attributes for selecting core features to implement. 
these attributes are critical in terms of fitness tracking app.

\item{Motivation}
Motivation engages users to workout, allowing users to meet personal fitness goals. This substantially increases the likelihood of app retention and routine adherence. 

\item{Consistency Assistance}
Consistency ensures the users to stick to their fitness journey, encouraging regular app usage. This is crucial for habit formation, fostering a routine usage pattern.

\item{Simplicity}
 Simplicity means focusing on core functionalities and clean interface, which enhances the app's ease of integration into daily routines and its overall user-friendliness. Avoiding unnecessary features that can clutter the app and confuse the use, and a simple interface with intuitive navigation helps users understand how to use the app quickly.

\item{Accuracy}
 Accuracy of the data collected by the app builds trust. Trust in the appâ€™s data accuracy is critical, as it not only impacts user confidence in the app but also influences their long-term fitness strategies and outcomes.

\item{Privacy}
The sensitivity of personal data handled by fitness apps heightens the importance of privacy considerations. Transparency in data management builds trust, ensuring users feel safe sharing their health data with the app.

Before delving into the specifics of individual features, it is important to establish a framework for understanding their broader impacts. The effectiveness of a fitness tracking application hinges on its ability to engage users and integrate seamlessly into their daily lives. Each feature plays a pivotal role in shaping the user's experience and the app's success.

A comprehensive examination of these features provides insights into how they enhance user satisfaction and the exercise experience. By highlighting the benefits and potential drawbacks of each feature, this analysis will explore how they collectively contribute to a fitness application:


\subsubsection{Workout Analysis} 

Workout Analysis Features comprise a comprehensive set of tools for tracking and evaluating athletic performance over time. Utilising various metrics, these tools chart an individual's progress, offering insights into their physical strengths and areas for enhancement. The continuous display of trends and performance improvements is crucial for the regular assessment of a userâ€™s fitness journey.

A key benefit of Workout Analysis Features is their ability to demonstrate quantifiable progress towards fitness goals, thereby boosting user motivation and consistency. Observing concrete progress and receiving performance feedback encourages users to persist and surpass their objectives, significantly aiding in sustained user engagement by continuously highlighting their accomplishments and necessary steps for ongoing improvement. These tools enable precise adjustments to workout plans based on solid data, facilitating more efficient training and better physical results. Additionally, the automation of data processing through smartphonesâ€”from gathering to calculating dataâ€”reduces errors common in manual entries, increasing data reliability and saving time. This automation simplifies the documentation and analysis of workout information, presenting it in easily understandable formats like graphs and charts, which help users easily visualise and comprehend their fitness progress over time.

Nevertheless, deploying Workout Analysis Features raises concerns, especially regarding privacy and data security. Storing and processing personal workout data, which may include sensitive health information, introduces potential risks. Users must be confident in the security of their data and the preservation of their privacy, which is not always assured. The possibility of a data breach could result in unauthorised access to personal information, emphasising the importance of robust security protocols and clear data management policies in fitness apps. 

    
\subsubsection{Goal Setting}

Goal Setting Features help users define and track fitness goals that align with their health ambitions. These features facilitate the establishment of specific, measurable objectives across various areas. Users input precise targets into these tools to monitor their advancement and remain focused on reaching their fitness milestones.

Creating explicit fitness goals is vital within any workout regimen, acting as a motivator and encouraging consistent exercise. Setting clear targets provides a structured guide for daily activities, increasing commitment to the exercise plan. This methodical setup sustains high motivation by offering achievable milestones, which enhance users' sense of achievement as they see their own progress. The goals' visibility in the app consistently reminds users of their aims, promoting ongoing interaction with the fitness program and increasing the chances of long-term app engagement.

However, there are drawbacks to setting goals, especially when the targets are unrealistic. Goals that do not account for an individualâ€™s physical limitations or realistic circumstances can cause feelings of failure and dissatisfaction, potentially reducing motivation and negatively affecting overall fitness engagement. Additionally, the requirement to enter and store personal health data for goal tracking raises privacy issues. The robustness of the app's security measures to safeguard sensitive information is essential; inadequate security can lead to data breaches, decreasing user trust and posing risks to personal information.

    
\subsubsection{Exercise Personalising}

Exercise personalisation is a feature that improves the flexibility of fitness apps by enabling users to incorporate custom exercises into their routines, catering to everyone from mainstream fitness enthusiasts to those engaged in niche or highly specific activities.

This feature allows for the customisation by adding preferred or specialised exercises, meeting the varied needs and interests of users and significantly boosting their engagement and satisfaction with the app. It is especially useful for individuals involved in specialised sports or activities requiring unique movements not typically found in standard exercise databases. Personalisation not only keeps exercises diverse and interesting but also allows users to adapt their fitness plans for specific objectives, such as injury rehabilitation or focused muscle development. By supporting the integration of tailored exercises, these apps appeal to a wide array of fitness enthusiasts. The ability to add unique exercises that meet individual preferences and needs enhances the appâ€™s usefulness and relevance, thus encouraging longer-term commitment and consistent exercise routines. Additionally, this feature increases the accessibility and inclusiveness of fitness apps, potentially attracting a larger audience with various physical abilities and training objectives.

However, exercise personalisation introduces several challenges. Users with limited knowledge of exercise fundamentals might add inappropriate or unsafe exercises to their routines, increasing the risk of injuries. Additionally, personalising exercises can complicate the appâ€™s capacity to track and analyse performance effectively. While most fitness apps use algorithms designed to monitor progress with predefined exercises, these may not perform as well with customised activities. This can lead to less accurate tracking and feedback for non-standard exercises, potentially reducing the app's effectiveness in monitoring progress and offering valuable insights.


\subsubsection{Routine Personalising} 

Routine personalisation in fitness applications allows users to design and adjust their own workout routines and categories, tailoring exercises to suit their unique needs and preferences. This feature enables the development of tailored workout sessions by amalgamating various exercises to match individual fitness objectives or training preferences. Users can select exercises from a vast database and categorise them into different groups such as cardio, strength, flexibility, and balance. This categorisation is further refined by parameters such as the equipment required, the intensity level, and the specific muscle groups targeted, allowing users to customise their workouts to achieve distinct goals like weight loss, strength enhancement, or improved flexibility. This high degree of personalisation not only aids in organising workouts more efficiently but also ensures that the routines are comprehensive and cater to personal fitness goals, covering a broad spectrum of physical activities.

The ability to create personalised workout routines offers significant benefits as it accommodates a diverse range of users, from beginners to advanced athletes, and from yoga aficionados to weightlifting enthusiasts. This flexibility allows individuals to craft exercise plans that resonate with their personal fitness levels, objectives, and schedules. Users' active involvement in designing these routines fosters a deeper commitment to their fitness journey, increasing engagement and satisfaction. Structured plans are crucial as they help prevent neglecting certain types of exercises or muscle groups, thereby promoting a balanced training regime. Moreover, systematically categorised and pre-planned routines streamline progress tracking, facilitate the recognition of patterns, and aid in making adjustments to meet fitness goals effectively. This organisation enhances the app's utility, making it easier for users to start exercising promptly, thus improving efficiency and user experience. By personalising their workout schedules, users gain a sense of ownership and control, which significantly boosts their motivation and enjoyment, ensuring that the regimen remains comprehensive and well-coordinated.

However, while the customisation of workout routines brings numerous advantages, it also poses certain challenges. Properly utilising this feature requires a solid understanding of exercise design principles to avoid creating unbalanced or ineffective workouts. For inexperienced users, there is a risk of developing routines that are either too demanding or insufficiently challenging, which can lead to injuries or lack of motivation. Additionally, personalising workouts complicates the appâ€™s capacity to track and analyse performance accurately. Fitness apps are generally equipped with algorithms that are fine-tuned for standard workouts, and these may not adapt well to customised, user-defined categories, potentially leading to imprecise feedback and suboptimal tracking of progress. This could detract from the appâ€™s effectiveness in aiding users to meet their fitness goals. 

    
\subsubsection{Fitness Calendar} 
Planning features in fitness applications, particularly the use of a workout planning calendar, are invaluable for helping users schedule individual workouts and manage their training phases. By allowing for the integration of fitness activities with other life commitments through a visual calendar, users can foster better habit formation, maintain regular exercise, and achieve a harmonious balance between fitness and other responsibilities.

The benefits of utilising a planning tool in fitness apps are significant. Effective planning facilitates the correct pacing of workouts, helping to prevent overtraining and injuries by ensuring adequate rest and recovery times. This structured approach not only enhances time management, allowing users to integrate their fitness routines seamlessly into their daily lives, but also supports the balancing of these commitments with personal and professional obligations. Effective planning aids in adhering to a consistent exercise routine by visually organising fitness activities around other commitments, leading to more realistic and sustainable workout plans and promoting better habit formation and balanced training.

However, integrating complex planning features into fitness apps can also present challenges. Over-planning may induce rigidity in exercise routines, making it difficult for users to adapt to unexpected changes in their schedule or physical condition, potentially leading to missed workouts or burnout. Additionally, while a comprehensive workout calendar can help integrate various activities, it may also complicate the app's interface, deterring users who prefer simpler interfaces. The presence of numerous features can overwhelm users, cluttering the app and creating confusion. Moreover, fitness apps are generally not designed to manage broader life scheduling needs, potentially reducing their effectiveness in meeting specific fitness planning requirements. Privacy concerns are another significant issue, as the storage of sensitive scheduling information necessitates robust security measures to protect user data. 

    
 \subsubsection{Reminders} 
 
Reminder features in fitness apps, such as workout notifications, are delivered through push notifications or alerts to inform users of upcoming workouts, integrating fitness more seamlessly into their daily routines. This feature ensures that workouts are not overlooked amidst the busy lives of users, enhancing the likelihood of achieving their fitness goals.

These reminders provide users with timely notifications, helping to maintain a regular workout schedule, which is essential for building and sustaining exercise habits. It facilitates better adherence to planned exercise regimens, making it easier for users to maintain a consistent exercise schedule. Especially when life becomes hectic, having a workout reminder ensures that exercise does not get sidelined. Regular alerts contribute to greater consistency in training, which is pivotal for the long-term development of healthy, consistent exercise routines.

While reminder features are designed to enhance consistent motivation, they come with potential downsides, such as notification fatigue. If notifications become too intrusive, users might start ignoring alerts or even disable them, leading to decreased engagement with the app. Excessive notifications can become a source of annoyance rather than assistance if they are too frequent or not intelligently scheduled to align with the user's lifestyle. This irritation can diminish user engagement and motivation, reducing the likelihood of the appâ€™s continued use.

    
\subsubsection{Social Networking} 
Socialising features in fitness apps enable users to share their workout progress and achievements with others, either within the app's community or on external social media platforms. These features foster a sense of community and collective engagement, allowing users to celebrate milestones publicly. By connecting with friends or joining fitness communities, users can share their daily achievements and compare their progress with that of their peers. The inclusion of social features in fitness apps offers several benefits, transforming exercise from a solitary activity into a shared, communal experience.

Socialising features enable users to connect through shared challenges and goals, leveraging the competitive and cooperative aspects of fitness. By allowing users to share their progress, these features foster a sense of community, providing social reinforcement and accountability, which are crucial motivators for maintaining an active lifestyle. Celebrating milestones publicly can enhance motivation and accountability, tapping into the social aspects of fitness, which can be a powerful motivator. The encouragement and support received from peers within the app can be highly motivating, helping users to remain consistent with their fitness routines.

Despite their benefits, socialising features in fitness apps can also present challenges. Privacy concerns are a significant issue for some users who may prefer to keep their fitness journey private rather than share details publicly, especially if the app shares updates beyond its platform or employs lax privacy controls. Moreover, constant social feeds and notifications can shift the focus from personal fitness goals to social interaction, potentially turning the app into a distraction similar to traditional social media. This can lead to negative comparisons with others, which might demotivate users. Furthermore, an overreliance on external validation for motivation can diminish intrinsic motivation, reducing the personal satisfaction derived from exercising. Additionally, apps with extensive social features can become complex to navigate, featuring numerous menus, settings, and notifications related to social interactions, which can complicate the user experience and detract from the app's core fitness functions.

    
\subsubsection{Gamification} 

Gamification features in fitness apps incorporate elements traditionally found in games, such as badges, achievements, points, levels, and progress bars, to motivate and engage users. By engaging in specific challenges, completing quests, or reaching fitness milestones, users can earn rewards and visually track their advancement, similar to progression systems found in video games. These features reward users for completing specific challenges and quests, allowing them to "level up" or observe their progress through visual progress bars. 

This integration of game-like elements provides tangible rewards for usersâ€™ efforts, enhancing their motivation and engagement with the app, thereby making the fitness journey both fun and rewarding. The inclusion of gamification elements in fitness routines can motivate users to persist in their fitness endeavors by rewarding them for meeting specific goals and challenges.

While gamification can offer benefits, it also has potential drawbacks. The focus on earning rewards and leveling up can sometimes overshadow the fundamental aspects of fitness. This shift in focus from health improvement to winning or scoring can undermine the true purpose of fitness activities. Furthermore, the novelty of gamification may diminish over time, which could decrease its motivational effect. Some users might perceive these features as gimmicky or trivial, detracting from the app's perceived value. Additionally, fitness apps with gamification interfaces can be challenging to navigate, potentially alienating users who prefer more straightforward, easy-to-use tools. The need to understand and engage with various gamification elements like point systems and levels requires extra cognitive effort, which could overwhelm some users, making the app seem cumbersome and detracting from its primary function of health monitoring and improvement. 

\subsection{Gamification} 

Efficient resource allocation and anticipation of development challenges are also vital components of the planning process. A comprehensive assessment of each feature's benefits and limitations allows developers to allocate resources judiciously, focusing on the most impactful features while minimizing investment in less critical areas. Identifying potential technical challenges early on enables the development of effective mitigation strategies, reducing the likelihood of costly future revisions. Furthermore, a well-researched feature set can provide a competitive edge by differentiating the app in the market through unique or superior functionalities that meet user needs more effectively. This strategic market positioning helps build brand trust and loyalty, enhancing user recommendations and expanding market reach. Ultimately, this detailed evaluation of feature impacts is essential for developing a technically robust, user-focused, and commercially successful fitness tracking app.

\begin{table}[ht]
\centering
\begin{tabular}{|m{4cm}|*{5}{c|}}
\hline
 & \textbf{Motivation} & \textbf{Consistency} & \textbf{Accessibility} & \textbf{Accuracy} & \textbf{Privacy} \\ \hline
\textbf{Workout Analysis}        & + & + & + & + & - \\ \hline
\textbf{Goal Setting}            &   & + &   &   & - \\ \hline
\textbf{Exercise Personalising}  &   & + & + & - &   \\ \hline
\textbf{Routine Personalising}   & + & + & + & - &   \\ \hline
\textbf{Fitness Calendar}        & - & + & - &   & - \\ \hline
\textbf{Reminders}               & - & + &   &   &   \\ \hline
\textbf{Social Networking}       &   & + & - &   & - \\ \hline
\textbf{Gamification}            & + & - & - &   &   \\ \hline
\end{tabular}
\caption{Impact of various features on key properties in health application design. The symbols `+' and `-' indicate a positive and negative effect, respectively, on the corresponding property. An empty cell indicates no effect. This table aids in identifying which features enhance or detract from user motivation, consistency, convenience, accuracy, and privacy.}
\end{table}


Aligning features with user needs not only enhances engagement and retention but also allows for the tailoring of offerings to individual preferences, thereby broadening market appeal and increasing user satisfaction. Features like goal setting and progress tracking not only motivate users by supporting regular exercise and healthy habits but also ensure that the app stands out in a competitive market through unique functionalities. Prioritising essential features through effective resource management optimises development efforts and ensures scalability, facilitating future growth without the need for extensive modifications. Additionally, features must incorporate robust security measures to protect user data and comply with privacy laws, ensuring user trust and regulatory adherence. The integration of these features into the app's architecture and user interface requires meticulous planning, from technical performance to aesthetic design, to enhance the overall user experience and functionality. This strategic approach to feature integration and testing assures that the app operates seamlessly, meeting the high standards required for successful market introduction and user adoption.

This phased approach allows for focused development and testing of features that are most likely to influence positive user engagement and satisfaction. By starting with an MVP that incorporates features with proven potential, the app can quickly establish a user base while minimizing initial risks and investments. The subsequent phases allow for scaling and refining the app's offerings based on concrete user data and feedback, thus enhancing the product's market fit and user retention rates over time.

By using the insights from the feature analysis as a guide, the app development plan is well-positioned to create a fitness tracking application that not only meets the current market needs but is also adaptable to future trends and user expectations. This strategic approach ensures that the app not only attracts but also retains a diverse and active user base, fostering sustained engagement and loyalty.



\subsection{Initial Development Phase: Minimum Viable Product (MVP)}

The first phase of development focuses on launching a Minimum Viable Product (MVP). This MVP will integrate core features that have demonstrated a significant positive impact on user engagement and satisfaction, according to the feature analysis table. The selection of features for the MVP is based on their ability to enhance key properties such as motivation, consistency, and accessibility, while ensuring data accuracy and maintaining user privacy.

\subsubsection{Selected Features for MVP}
The features chosen for the MVP include:

\textbf{Workout Analysis}: This feature supports motivation and consistency by providing users with detailed feedback on their performance, helping them to track progress effectively.
\textbf{Routine Personalising}: Enhances motivation by allowing users to tailor their workouts, which improves both the personal relevance and effectiveness of the fitness regimen.
\textbf{Exercise Personalising}: Increases accessibility by enabling users to include exercises that cater to their specific needs and preferences, promoting broader usability.
These features are selected for their positive contributions to the key attributes of successful fitness apps, while also considering their technical feasibility and the resource allocation available for the MVP.



\subsection{Selecting a Template and Configuring the Development Environment}

The development process begins with selecting the appropriate template from Android Studio's "New Project" options. The Bottom Navigation Views Activity template is chosen for a fitness app aimed at providing an intuitive navigation. This template offers a basic yet effective app structure that includes a navigation bar at the bottom of the screen, allowing users to easily switch between different views or functionalities of the app.

The emulator within Android Studio is configured to simulate various devices and Android versions, ensuring that a mobile app provides a consistent experience regardless of the user's device specifications or operating system version. Considering the minimum API requirements and various API versions, emulators were set up and compile tests were performed. Performing the initial compile tests before feature development is undertaken is vital for stable development, to ensure that the basic structural setup of the app is technically sound and free from any fundamental errors.


\subsection{Implementing .gitignore to Streamline Version Control}

For Kotlin Android app development, files generated by Android Studio and Gradle that do not need to be tracked and can clutter the repository are excluded from version control using the .gitignore file. This configuration simplifies the version control process by keeping the repository clean and focusing on meaningful changes, thus providing an unambiguous codebase.


\subsection{MVP Functionality Implementation}

The initial version of app functions similarly to standard fitness trackers, emphasizing customizable tracking features. Users can log quantifiable data, manage exercises by adding or deleting them, and record their workouts. Additionally, the app's version can be verified through the settings screen.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/MVVM-MVP.png}
    \caption{Diagram of the initial version of the app using a Model-View-ViewModel (MVVM) architecture. This diagram highlights the modular organization between the Model, View, and ViewModel components.}
    \label{fig:mvp_MVVM}
\end{figure}

\subsubsection{Home Fragment: Log Activity}

\noindent
The Home Fragment features two main views: a TextView and a RecyclerView. The TextView is positioned to provide user instructions, prominently displaying the message "select exercise" to guide users in choosing from the list displayed in the RecyclerView below. This RecyclerView, located at the bottom of the layout, presents a list of exercises added by the user, with the top part of the layout left empty for muscle visualization purposes. 

The adapter for this RecyclerView has methods for adding and removing items. The `addItem` and `removeItem` methods allow direct manipulation of the adapter's dataset, with `addItem` introducing a new `ExerciseCard` to the list and `removeItem` eliminating an entry from a specified position. Both operations utilize `submitList()`, a `ListAdapter` method that refreshes the list on a background thread to calculate differences, subsequently updating the UI on the main thread. This integrated approach streamlines dataset management within the `HomeCardAdapter`, enhancing both functionality and user experience.

\begin{figure}[h]
    \begin{figure}[h]
    \centering
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/MVP_home.png} 
        \caption{Screenshot of the HomeFragment displayed on a Moto G5 testing device.}
        \label{fig:mvp_homeFragment}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/MVP_addLog.png} 
        \caption{Screenshot of the AddLogActivity
displayed on a Moto G5 testing device.}
        \label{fig:mvp_addLogActivity}
    \end{minipage}
\end{figure}

\noindent
The ViewHolder incorporates a TextView to display an exercise, detailing the exercise name, last activity date, main muscle group, sub muscle group, tags, and the personal best 1RM record. In the MVP stage, the tags and 1RM calculation algorithm were not implemented, resulting in "null" for tags and "placeholder" for the 1RM record, as displayed in Figure \ref{fig:mvp_homeFragment}. The bind method of the ViewHolder not only populates the information from the data but also sets an OnClickListener. This button triggers the AddLogActivity when clicked, transferring the ExerciseCard data as an extra. It facilitates interaction within the RecyclerView items, enabling the initiation of new activities and data transmission. 

When a user selects an exercise from the RecyclerView, the AddLogActivity is launched via this Intent mechanism, allowing them to log details for the selected exercise. The "ExerciseLog" data class supports nullable values for mass (mass: Float?) and repetitions (rep: Int?), allowing users to optionally leave these fields blank for a broader range of exercise logging. This flexibility in data entry, combined with structured data storage, streamlines data handling and promotes efficient data exchange across the application components. When a user enters their exercise log and clicks the "add log" button, the log is stored locally using the "LogStorage.kt" class. This class is responsible for loading, saving, adding, and deleting logs from the storage. It utilizes local storage through the "exercise\_logs.dat" file for storing all log entries. The operations within this class are safeguarded by try and catch blocks to handle potential file I/O errors.


% ---------------------

\subsubsection{Status Fragment: Customising Exercise}

\begin{figure}[h]
    \centering
    \begin{minipage}[t]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/MVP_status.png}
        \caption{Screenshot of the StatusFragment displayed on a Moto G5 testing device.}
        \label{fig:mvp_statusFragment}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/MVP_addCard.png}
        \caption{Screenshot of the AddCardActivity displayed on a Moto G5 testing device.}
        \label{fig:mvp_addCardActivity}
    \end{minipage}\hfill
    \begin{minipage}[t]{0.3\textwidth}
        \centering
        \includegraphics[width=\textwidth]{figures/MVP_addCard_spinner.png} 
        \caption{Screenshot of the AddCardActivity with an expanded spinner displayed on a Moto G5 testing device.}
        \label{fig:mvp_addCardActivity_spinner}
    \end{minipage}
\end{figure}


\subsubsection{Setting Fragment: Version Control}

The Status Fragment is modified from the template's Dashboard Fragment and plays a crucial role in allowing users to customize the exercises they wish to track with the app. This customization is achieved through the capability to add and delete exercises directly within this fragment.

By tapping the "ADD A NEW EXERCISE" button, users are directed to the "AddCardActivity." Here, they can input the name of the exercise using an EditText view and select muscles for both the main and sub categories using spinners. These spinners are populated with muscle names stored in an array within the app/src/main/res/values directory, facilitating easy and accurate entry of muscle groups for customized exercises.

Upon entering the required data and clicking the "ADD" button, the new exercise is saved locally in the "exercise\_cards.dat" file managed by CardStorage.kt. Each exercise card includes a unique ID and the time it was addedâ€”both automatically generatedâ€”as well as the initial last activity date, set to the day the card is created. Additionally, a tag attribute implemented as a List<String> is included to lay the groundwork for future categorization features, allowing exercises to be organized according to user preference.

If users decide to remove an exercise, they can do so by clicking the "DELETE" button. Any additions or deletions of cards are promptly reflected in the RecyclerView displayed on both the Status and Home Fragments, kept current through the use of a ListAdapter and LiveData. This setup ensures that the interface is always up-to-date, showing the latest changes made by the user.


\subsubsection{Setting Fragment}


The Settings Fragment has been developed by modifying the Notifications Fragment that comes with the Bottom Navigation Views Activity template. It incorporates the use of a SettingViewModel, which utilizes LiveData to manage data related to settings. Specifically, this model tracks the current version of the app. It attempts to retrieve the app version from the package manager, and if successful, it updates the LiveData with the version information, formatted as "app version : [version name]". This setup allows users to view the most current version of the app directly from the Settings Fragment, ensuring they have access to up-to-date information. If there is an issue retrieving the version data, such as the package name not being found, the error is handled gracefully, maintaining the app's stability.


% -----------------------------------------------------------------------------


\section{Advancing User Engagement: Iterative Design and Enhanced Functionality in Version 2 of TrainingTracker(TT)}

it involves version 1.5 implementation and version2

\subsection{version 1.5}

In version 1.5 of the software project, enhancing the user interface (UI) design to improve user experience was a primary focus, setting the stage for the integration of upcoming features planned for version 2.0. Central to this phase was the strategic selection of a yellow and blue colour palette to accommodate users with red/green colour blindness, demonstrating a solid understanding of accessibility principles in UI design.

The method of defining this colour scheme in the `colors.xml` file and consistently applying these colours throughout the app using `themes.xml` is correct and aligns with best practices in Android development. This ensures maintainability and uniformity of the UI design, creating a cohesive appearance across various UI elements such as buttons and the bottom navigation bar, thereby enhancing the overall aesthetic appeal of the app.

Additionally, adopting scalable vector graphics (SVG) for the app logo supports visual consistency and branding. Utilising SVGs, which are resolution-independent and scale without losing quality, is effective for maintaining sharp visuals across different device resolutions. The use of Inkscape for creating these SVGs, although a detail typically outside the immediate scope of software versioning, underscores a technically sound approach to asset creation.

This meticulous attention to UI design details not only reinforces the brand identity but also significantly enhances the user interface, making it more engaging and accessible to all users. The technical explanations provided align well with standard practices in Android app development using Kotlin, ensuring that the description is both accurate and informative for individuals familiar with the field.

\subsubsection{home and status fragment}

In the development of version 1.5 of the application, significant improvements were made to both the Home and Status fragments to enhance usability and aesthetics. Initially, the app used individual log buttons within each RecyclerView item to access the add log activity, which cluttered the interface and detracted from user convenience. To address this, I removed these buttons, making each element in the RecyclerView clickable itself, thereby streamlining the process where users can initiate an add log activity by simply selecting the desired exercise.

Simultaneously, to reduce redundancy and improve the user experience on the Status screen, I eliminated the "delete" buttons. Instead, users can now delete an exercise by long-pressing on an item and selecting the delete option from a context menu. This change was mirrored in the Home fragment to maintain consistency across the user interface.

Additionally, design enhancements were implemented to the RecyclerView elements to increase clarity and usability. Each element was styled using a card layout, creating visual separation and helping users recognise each item as distinct. This was further enhanced by managing the visibility of certain elements to avoid displaying extraneous information, focusing user attention on essential details, formatted for clear understanding.

A new feature in the card layout includes a field for personal records, setting the stage for future functionality that will leverage these data points. I also customised the scrollbar within the RecyclerView to reflect the application's consistent colour scheme, aiding users in visually tracking their position within the list and the number of items displayed.

To further prepare for upcoming features, I added a tag bar above the RecyclerView for future functional expansion and designed visualised muscle groups displayed above this bar. These were created as drawable vector paths using Inkscape, based on research into commonly exercised muscle groups. This preparation involved sketching the muscle groups, categorising them, and then digitally rendering them into vectors, ensuring that each graphic was scalable and visually cohesive with the overall design of the application. These enhancements not only improve current functionality but also lay the groundwork for more sophisticated features in subsequent releases.


\subsubsection{add log activity}


In version 1.5 of our application, the Add Log Activity underwent significant redesigns to optimise the limited screen space and enhance user navigation based on insights gained from personal testing of the app. Recognising the need for a more intuitive logging experience, I implemented the display of the exercise name on the action bar during log entries. This constant visual cue helps ensure users remain oriented and reassures them that their inputs are being recorded under the correct exercise category, minimising confusion and errors. These improvements, driven by direct observation and hands-on testing, not only enhance the appâ€™s functionality but also significantly refine the user experience by making the workout logging process more intuitive and efficient.

The application adeptly manages screen space through a RecyclerView combined with dynamic space allocation. This design maximises the use of available screen space effectively. The RecyclerView is utilised to display a table of logs, allowing for easy access to past entries. Even if all logs do not fit on the screen simultaneously, users can scroll to view any previous logs. Initially, the screen predominantly displays past logs; however, as new logs are entered, the system dynamically adjusts to increase the space allocated to the current session's data. As more logs are added, the space dedicated to displaying past logs gradually decreases, making room for the new logs being entered. To optimise the display of current logs, I used 'wrap\_content' for the height of the new logs section and placed the RecyclerView for the remaining page. 

Anticipating future enhancements, I prepared the layout to include analysis displays featuring CardViews for summarised data and GraphViews to chart exercise progress. This setup is intended to provide easy and intuitive access to analytical insights without leaving the logging screen.

I identified the inconvenience of needing to switch between screens to view past performances while entering new data. To address this, I integrated past logs directly on the logging screen. Displayed in a table format, these logs only show entries corresponding to the exercise currently being logged, employing two distinct row layouts to separate date information from exercise details such as set count, weight lifted, and reps completed. This design enhances clarity and allows for effective organisation of data. 

To further customise the logging experience, I implemented an option to omit the set count for each entry, catering to different workout preferences such as warm-up sets or varied-weight sets within the same exercise. This flexibility supports more personalised logging and better reflects the diversity of real-world workout routines. Upon completion of a logging session, the data is automatically saved to local storage on the phone. 

Significant updates to the data model were also introduced to improve logical consistency and efficiency. When users engage in exercise, each session involves multiple sets. Additionally, each set consists of weight lifted, reps completed, and a predicted one-repetition maximum (1RM) calculated from the weight lifted and reps completed that users input. I implemented the ExerciseSet data class reflecting this real-world data structure. For the 1RM calculation, a one rep max algorithm is implemented. To enhance the accuracy of this calculation, I employed four different algorithms to calculate the 1RM and then calculated the average value, thus employing a structure that mirrors real-world workout routines.

Alongside this, The class for each session, namely ExerciseLog, is updated to contain a set of sets completed during the workout. The 'lastActivity' attribute in this class became nullable. In version 1, this attribute automatically updated the last activity to the date the exercise was created. However, this doesn't logically make sense because entering a new kind of exercise doesn't necessarily mean the exercise was actually performed. For this reason, to handle cases where there may not be a date of last activity, this attribute has been changed to a nullable attribute. This attribute is only updated when users are actually entering the logs for that exercise. This modification was made to better track the last activity a user entered. Additionally, to optimise data management, each ExerciseLog now references the corresponding ExerciseCard by its unique UUID, streamlining the storage process by avoiding redundancy and enhancing data retrieval.

\subsubsection{setting fragment}
The Settings Fragment underwent several layout modifications to enhance both its functionality and organisation. These adjustments not only ready the application for the integration of additional features but also improve the overall clarity and efficiency of the user interface design. Specifically, the textView that displays the app version was relocated to the bottom of the screen. This change was implemented to free up space at the top of the layout, creating room for the addition of new buttons that will accommodate future functionalities.

To further streamline the layout and enhance maintainability, I introduced a new system for renaming layouts within the XML files. This system utilises a standardised naming convention that amalgamates the layout name with the content and view type it contains, structured as `LayoutName\_Contents\&ViewType`. This methodology significantly clarifies the structure of the layout files, facilitating easier understanding and management. By distinctly delineating what each layout section represents and its purpose, it reduces ambiguity during the data binding process to the views, enabling a more intuitive development process and expediting future updates or modifications.
% -----------------------------------------------------------------------------



\subsection{version 2}


\subsubsection{Enhancing Scalability and Maintainability through Centralised Formatting and Structured Data Management}

In the development of my Android application using Kotlin, significant emphasis was placed on enhancing both the scalability and maintainability of the software to ensure efficient performance and ease of future updates. These improvements demonstrate not only technical proficiency in Android development and Kotlin programming but also a strategic approach to software architecture. The use of design patterns such as the factory pattern for data management and centralised control for string formatting are indicative of advanced programming skills and a commitment to creating scalable, maintainable, and robust software applications.

A major advancement in this regard was the introduction of a centralised string formatting mechanism. This mechanism, encapsulated within a class called `FormattedStringGetter`, is crucial for maintaining consistency across the app's user interface. It provides a unified approach to converting data into strings, allowing for uniform presentation and simplification of modifications. By centralising string formatting, any required changes to the data presentation can now be managed in one location, rather than across multiple classes, enhancing the maintainability and reducing the potential for inconsistencies.

Moreover, I significantly improved data management by employing the factory design pattern, a decision that streamlined the instantiation process of data objects throughout the application. This architecture involves factories that are designated to create objects based on predefined data classes. These factories not only enforce a consistent creation process but also simplify the handling of special data cases. By centralising object creation, updates to data classes or their instantiation logic are confined to a single point of modification, thereby increasing the flexibility and scalability of the application.

To further bolster the robustness of the application, I enhanced the data storage and error handling mechanisms. By making the data storage methods private and employing detailed exception handling strategies, the application ensures data integrity and enhances security. These methods are designed to gracefully manage exceptions, providing reliable fallback mechanisms to maintain the application's functionality. This careful management of exceptions and data integrity checks are indicative of high programming standards and a deep understanding of software reliability and user data protection.


\subsubsection{Muscle Status Visualization for Improved Workout Management and Recovery Tracking}

The muscle visualisation feature significantly enhances user interaction and management of workout progress for each muscle group. The application provides a visual representation of muscle status, indicating whether a muscle is fully recovered, in recovery, or has been inactive for an extended period. Each state is distinctly coloured, allowing users to quickly ascertain the status of their muscles at a glance. This holistic approach not only enriches user engagement with the app by providing clear visual cues and updates but also augments the functionality and accuracy of workout tracking.

To efficiently manage this feature, I introduced a 'Muscle' class, which acts as a bridge between the muscle vector graphics and the associated muscle status data. This class is instrumental in dynamically updating the displayed colours of the muscle graphics based on their current status. It accomplishes this by comparing the saved muscle dataâ€”including names and statusesâ€”with the drawable assets' file names, enabling the app to accurately display the appropriate muscle status for each group. If no data is loaded, the system initialises with default values, setting the 'lastActivity' attribute to null and the initial status to fully recovered, as this process occurs when the user runs the app for the first time, indicating that no workouts have been recorded yet.

The app determines muscle status by comparing the 'lastActivity' timestamp in the muscle data with the current time. Upon each app launch, it refreshes the muscle states by checking the current time and applying a logical algorithm to ascertain the muscle's condition. If 'lastActivity' is null (indicating the app is run for the first time), it assigns the current time for further muscle status tracking. If a muscle has not been exercised for more than ten days, the system flags it as needing exercise; if it has been worked out within the last two days, it indicates that the muscle is in recovery. If none of these conditions apply, the muscle is considered fully recovered. Following this update, the status within the muscle data class is adjusted, and the system then links the updated status to the appropriate drawable resource for visual representation.

To further tailor the user experience, the application includes a feature allowing users to customise exercises with any number of associated muscle groups. This customisation is facilitated by a spinner that can select multiple items, ensuring users can specify both main and sub-muscle groups for each exercise log. When an exercise log is entered, the application checks the associated muscle groups and updates their status to 'being recovered', and updates the lastActivity.

\subsubsection{Enhancing User Customisation and Exercise Management through Efficient Tagging and Advanced Filtering Mechanisms}
To enhance user customisation and improve the filtering capabilities of my Android application, I implemented a tagging feature that allows users to create and manage custom categories. Users can add tags based on their preferences, enabling them to customise routines and group specific exercises according to muscle groups or other criteria.

The initial attempt to implement this feature involved using strings to represent each tag. However, this approach led to several issues, such as the inability to create tags with identical names and difficulties in managing tag properties like colour changes based on their selection status. To address these issues, I developed a more robust solution in my second implementation attempt.

In this version, I designed a dedicated `Tag` data class to provide a clear structure for tag management. Each tag consists of a unique ID, the time it was added, a name, and a boolean value (`isSelected`) indicating whether the tag is selected. This structure enables better handling of tags, ensuring that each tag is distinct and manageable. Additionally, `ADD\_TAG` and `SELECT\_TAG` were added as companion objects within this class to facilitate tag customisation and selection.

Tag bars were integrated into the home fragment and status fragment to support filtering. The `ADD\_TAG` functionality allows users to add new tags by clicking on the `ADD\_TAG` icon on the tag bar, which is implemented using a horizontal `RecyclerView`. This icon is always the last element on the tag bar, providing a consistent location for users to add new tags. The tag bar displays all user-added tags, enabling efficient tag management and selection.

The filtering mechanism works by retrieving selected tags from local storage and then filtering exercise cards based on these tags. If a card contains any of the selected tags, it is displayed; otherwise, it is hidden. When no tags are selected, the filter is disabled, and all exercises are shown. The selected tags persist throughout the main activity's lifecycle, ensuring that users do not need to reselect tags when navigating between fragments. This persistence enhances the user experience by maintaining filter settings across the home and status fragments, allowing seamless transitions without losing tag selections.

Tags can be assigned to exercise cards when users add exercises. The `SELECT\_TAG` companion object is used to display a spinner hint, making it the first tag shown in the spinner. Users can select multiple tags using a multi-select spinner, enabling them to assign numerous tags to an exercise as needed. 


\subsubsection{Workout Analysis with 1RM Tracking for Comprehensive Insights and Improved User Engagement}
In the latest update to our fitness app, I have significantly enhanced the workout analysis capabilities to provide users with meaningful insights into their exercise progress. This improvement centres around the integration of a one-repetition maximum (1RM) calculation across various components of the app, enabling users to track strength gains over time. These enhancements not only streamline the user experience by integrating critical performance data directly where it's most relevant but also encourage ongoing engagement by continuously highlighting progress and achievements directly within the workout logs and home screen displays.

To facilitate this, I first updated our data structure by adding a `oneRepMax` attribute to the `ExerciseSet` class. Each time a user logs an exercise set, the app automatically calculates the 1RM for that set and assigns it to this new attribute. This calculation is foundational for tracking the maximum strength output across individual sessions. Next, I introduced a `oneRepMax` attribute to the `ExerciseLog` class. After a user completes logging an exercise, the app compares all the 1RM values from the sets entered during that session and records the highest value. This maximum 1RM value per session is crucial as it allows users to see how their strength has evolved from session to session.

Furthermore, I enhanced the `ExerciseCard` class by also integrating the `oneRepMax` attribute. Whenever a new exercise log is saved, the app checks if the 1RM from this log exceeds the current maximum recorded on the corresponding ExerciseCard. If so, it updates the card's 1RM. This feature not only tracks personal bests but also serves as a motivational tool by showcasing users' strength improvements over time.

Workout analysis is prominently accessible via the status fragment, where users can view all exercise logs along with corresponding analyses in one consolidated screen. Below each exercise cardâ€”detailing exercise names, main and sub-muscle groupsâ€”the personal best 1RM and a graph illustrating the progress are displayed. This section also highlights the date the personal best was achieved, encouraging users to continue striving for new records. Additionally, all the original exercise logs are presented in a tabular format below this analysis for detailed review.

Notably, analysis features are also integrated into the logging screen. This unique aspect of the app ensures that users do not need to navigate away to separate screens to view their performance analytics; instead, relevant logs and analyses are automatically presented as they enter their workout records. A simpler version of the 1RM analysis is also available on the home screen, providing quick glimpses of personal bests and the dates they were achieved, similar to the status fragment but optimised for at-a-glance viewing.

Given the shift of workout analysis to the status screen, I relocated the functionality to add custom exercise cards, which was initially part of the status fragment, to the home screen. To facilitate this transition smoothly, I introduced a floating action button on the home fragment. Initially fixed, I later made this button draggable to optimise screen space usage and minimise obstruction of content. When not actively used, the button becomes semi-transparent and automatically aligns to the screen's edges, thus reducing visual distraction and maximising the available display area for exercise cards.


\subsubsection{Facilitating Direct User Interaction and Optimised Feedback Integration with Communication Tools}

In version 1.5 of our application, I introduced a revamped settings screen designed to enhance the user experience by facilitating direct communication between users and the development team. This update includes the addition of three crucial buttons: 'Report Error', 'Send Feedback', and 'Privacy Policy'. These new features transform the settings fragment into a hub for user interaction, allowing users to play an active role in the appâ€™s development and improvement, which in turn increases the app's accessibility and user satisfaction. 
By incorporating these settings and functionalities, the app not only becomes more aligned with user needs but also adheres to best practices for data management and user privacy. This setup ensures users are well-informed about how their data is used and provides them with straightforward mechanisms to contribute to the appâ€™s ongoing development, thus fostering a sense of community and co-creation.

The 'Report Error' and 'Send Feedback' functions are designed to allow users to communicate directly with the development team via email. For this purpose, I set up a specific email account dedicated to the app (trainingtrackermainbox@gmail.com). When users choose to report an error or send feedback, they can fill out their message directly within the app and send it by email. Implementing this required the app to access the internet, which necessitated adding specific permissions to the app's manifest file. The permission `android.permission.INTERNET` is essential to enable the app to open internet connections for sending emails, ensuring that the feedback process is smooth and effective.

In addition to these communication tools, I included a 'Privacy Policy' button to clarify how user data is handled, especially in scenarios where users report errors. This policy explains that the app may collect diagnostic information from the local data stored on the userâ€™s device to better understand the context of any issues reported. This can help identify if problems arise from data loading failures, allowing for more targeted troubleshooting.

% -----------------------------------------------------------------------------

\subsection{Market Introduction: Integrating Researched Factors for a User-Centred Approach}

\subsubsection{Preparing for Market Release for Successful App Deployment}
To successfully introduce my Android app to the market, I undertook a series of essential steps to prepare it for release not only on the Amazon Appstore but also on GitHub, ensuring a broad distribution that aligns with best practices in software deployment. These strategic steps facilitated a smooth launch on both platforms and established a strong foundation for maintaining the app's integrity and user trust post-release. Each measure was carefully planned to align with the technical requirements of app deployment while ensuring the app remains identifiable, secure, and consistent with my brand as a developer.

Initially, I defined the version name and code for the app, crucial for both users and the distribution platforms to identify different iterations of the software. The version name provides a user-friendly label that reflects the release stage, such as 1.5.2, while the version code is a unique integer that internally helps manage updates and compatibility, ensuring that users always have access to the latest features and security enhancements.

A significant change I implemented was updating the package domain from a generic placeholder (`com.example.trainingtracker`) to a more personalized and professional one (`com.jeein.trainingtracker`). This not only prevents potential conflicts with other apps on the Amazon Appstore but also enhances the app's branding, making it easily recognizable and traceable to my developer identity. Such a change underscores the app's authenticity and aids users and other developers in associating it with my other products and services.

In preparation for release, I managed two build variants in the Android Studio: a debuggable 'debug' variant used during development for testing and troubleshooting, and a 'release' variant, which is optimized for public use and not debuggable. The separation of these builds ensures that the end-users receive a version of the app that is secure and performs efficiently, as the debuggable version could potentially expose sensitive data or underlying code logic.

Finally, the process of generating a signed APK was crucial for the Amazon Appstore release, and similarly, preparing a release-ready package for GitHub was essential. Signing the APK serves as a seal of authenticity, verifying that any updates to the app come directly from me, the legitimate developer, and have not been tampered with since their release. To achieve this, I generated a key store file, a secure container for the keys used to sign the APKs. This file is vital for the appâ€™s update pipeline; losing it would prevent future updates under the same app identity. I configured Android Studio to use this key when building the 'release' variant, ensuring every APK released is properly signed and ready for deployment. On GitHub, I made the source code available for other developers to view, use, or contribute to, enhancing collaborative development and transparency.


\subsubsection{Strategic GitHub Presentation for Improved Accessibility and Engagement}
In the process of releasing my app on GitHub, I ensured that the presentation and accessibility were meticulously addressed to enhance user engagement and transparency. A promotional image (feature graphic) was utilised prominently on the repository's README file, capturing the essence of the app and attracting potential users. Additionally, I included a comprehensive privacy policy within the README to ensure users were well-informed about data handling practices, aligning with ethical standards and compliance requirements.

To facilitate easy access to the app, I hyperlinked the uploaded APK file within the README as well as in the release description. This dual placement ensured that users could effortlessly download the app from multiple points within the repository. The release description was further enriched with feature bullets that clearly outlined the changes and improvements made from the initial version, providing users with a transparent and concise update log. This strategic approach in my GitHub release not only highlighted my attention to detail and user-centric design but also showcased my proficiency in managing software distribution and version control effectively.

\subsubsection{app testing and version 2.1 implementation}

\subsubsection{Comprehensive App Store Setup for Optimal User Discovery and Engagement}
Releasing an app on an app store involves a comprehensive setup of various elements that contribute to how the app is presented and discovered by potential users. Each component plays a crucial role in ensuring that the app meets store guidelines and appeals effectively to its intended audience.

\begin{itemize}
    \item \textbf{App Title}: This is the name of your app as it appears in the store. It's essential for branding and first impressions. The title should be memorable, relevant to the appâ€™s functionality, and optimised for search queries.

    \item \textbf{App SKU (Stock Keeping Unit)}: This is a unique identifier used internally to track your app. It helps in distinguishing different versions and variations of your app within your developer account.

    \item \textbf{App Category and Subcategory}: These classifications help users find your app based on their interests. Selecting the correct category and subcategory improves visibility to users who are likely to be interested in your app.

    \item \textbf{Language Support}: This defines the languages your app supports, directly affecting its accessibility to users in different regions. Supporting multiple languages can significantly expand your appâ€™s potential user base.

    \item \textbf{Customer Support Contact}: Itâ€™s essential to provide a way for users to reach out with issues or questions. Good customer support can improve user satisfaction and retention.

    \item \textbf{Availability (Countries/Regions)}: This setting determines where your app can be downloaded. Not all apps are suitable for all markets, and legal restrictions or localisations might dictate availability.

    \item \textbf{Target Audience (Age Groups)}: Knowing your target audience allows you to tailor your appâ€™s content and marketing to suit their preferences and needs, and it ensures compliance with age-specific regulations.

    \item \textbf{Content Rating}: This reflects the nature of your appâ€™s content, such as if it includes mature themes. A proper content rating prevents exposure to inappropriate content and fulfils legal obligations.

    \item \textbf{User Data Privacy}: This is a statement of how your app collects, uses, and protects user data. Transparency in data handling practices is crucial for compliance with global privacy laws and for earning user trust.

    \item \textbf{Appstore Detail}: This encompasses all the metadata related to your app, including the description, keywords, and graphical assets. It plays a critical role in how your app is perceived and discovered.

    \item \textbf{App Pricing}: Setting the right price for your app can affect its uptake. You may choose to offer it for free, as a paid purchase, or with in-app purchases.

    \item \textbf{Description}: This is a detailed overview of what your app does and its key features. A well-written description can improve conversion rates by convincing potential users of the appâ€™s value.

    \item \textbf{Feature Bullets}: These are quick, bullet-point highlights of your appâ€™s main features. They are designed to quickly inform users about what sets your app apart from others.

    \item \textbf{Keywords}: Keywords affect how easily users can find your app through search. Choosing the right keywords requires understanding your audience and what terms they might use to find an app like yours.

    \item \textbf{Icon}: The app icon is one of the first visual elements a potential user sees. It should be visually appealing and representative of the appâ€™s purpose.

    \item \textbf{Screenshots}: Screenshots showcase the appâ€™s interface and functionality. They help users form their first impressions and can be decisive in the download decision.

    \item \textbf{Promotional Image (Feature Graphic)}: This is used in various promotional contexts, potentially being the first image a user sees in the app storeâ€™s featured lists or search results. It needs to capture the essence of your app attractively and effectively.
\end{itemize}

Each of these components plays a strategic role in how your app is marketed and perceived on the app store. Proper attention to each detail can significantly enhance your appâ€™s visibility, appeal, and ultimately, its success on the platform.

% -----------------------------------------------------------------------------


\subsection{Continuous Improvement: Integrating User Feedback and Agile Reflection}


% -----------------------------------------------------------------------------



\section{Evaluating Workout App Performance: Efficiency and User Satisfaction Metrics}


% -----------------------------------------------------------------------------

\chapter{Critical Evaluation}
\label{chap:evaluation}

{\bf A topic-specific chapter} 
\vspace{1cm} 

\noindent
This chapter is intended to evaluate what you did.  The content is highly 
topic-specific, but for many projects will have flavours of the following:

\begin{enumerate}
\item functional  testing, including analysis and explanation of failure 
      cases,
\item behavioural testing, often including analysis of any results that 
      draw some form of conclusion wrt. the aims and objectives,
      and
\item evaluation of options and decisions within the project, and/or a
      comparison with alternatives.
\end{enumerate}

\noindent
This chapter often acts to differentiate project quality: even if the work
completed is of a high technical quality, critical yet objective evaluation 
and comparison of the outcomes is crucial.  In essence, the reader wants to
learn something, so the worst examples amount to simple statements of fact 
(e.g., ``graph X shows the result is Y''); the best examples are analytical 
and exploratory (e.g., ``graph X shows the result is Y, which means Z; this 
contradicts [1], which may be because I use a different assumption'').  As 
such, both positive {\em and} negative outcomes are valid {\em if} presented 
in a suitable manner.

% -----------------------------------------------------------------------------

\chapter{Conclusion}
\label{chap:conclusion}

\noindent
The concluding chapter of a dissertation is often underutilised because it 
is too often left too close to the deadline: it is important to allocate
enough attention to it.  Ideally, the chapter will consist of three parts:

\begin{enumerate}
\item (Re)summarise the main contributions and achievements, in essence
      summing up the content.
\item Clearly state the current project status (e.g., ``X is working, Y 
      is not'') and evaluate what has been achieved with respect to the 
      initial aims and objectives (e.g., ``I completed aim X outlined 
      previously, the evidence for this is within Chapter Y'').  There 
      is no problem including aims which were not completed, but it is 
      important to evaluate and/or justify why this is the case.
\item Outline any open problems or future plans.  Rather than treat this
      only as an exercise in what you {\em could} have done given more 
      time, try to focus on any unexplored options or interesting outcomes
      (e.g., ``my experiment for X gave counter-intuitive results, this 
      could be because Y and would form an interesting area for further 
      study'' or ``users found feature Z of my software difficult to use,
      which is obvious in hindsight but not during at design stage; to 
      resolve this, I could clearly apply the technique of Smith [7]'').
\end{enumerate}

% =============================================================================

% Finally, after the main matter, the back matter is specified.  This is
% typically populated with just the bibliography.  LaTeX deals with these
% in one of two ways, namely
%
% - inline, which roughly means the author specifies entries using the 
%   \bibitem macro and typesets them manually, or
% - using BiBTeX, which means entries are contained in a separate file
%   (which is essentially a databased) then inported; this is the 
%   approach used below, with the databased being dissertation.bib.
%
% Either way, the each entry has a key (or identifier) which can be used
% in the main matter to cite it, e.g., \cite{X}, \cite[Chapter 2}{Y}.
%
% We would recommend using BiBTeX, since it guarantees a consistent referencing style 
% and since many sites (such as dblp) provide references in BiBTeX format. 
% However, note that by default, BiBTeX will ignore capital letters in article titles 
% to ensure consistency of style. This can lead to e.g. "NP-completeness" becoming
% "np-completeness". To avoid this, make sure any capital letters you want to preserve
% are enclosed in braces in the .bib, e.g. "{NP}-completeness".

\backmatter

\bibliography{dissertation}

% -----------------------------------------------------------------------------

% The dissertation concludes with a set of (optional) appendicies; these are 
% the same as chapters in a sense, but once signaled as being appendicies via
% the associated macro, LaTeX manages them appropriatly.

\appendix

\chapter{An Example Appendix}
\label{appx:example}

Content which is not central to, but may enhance the dissertation can be 
included in one or more appendices; examples include, but are not limited
to

\begin{itemize}
\item lengthy mathematical proofs, numerical or graphical results which 
      are summarised in the main body,
\item sample or example calculations, 
      and
\item results of user studies or questionnaires.
\end{itemize}

\noindent
Note that in line with most research conferences, the marking panel is not obliged to read such appendices. The point of including them is to serve as an additional reference if and only if the marker needs it in order to check something in the main text. 
For example, the marker might check a program listing  in an appendix if they think the description in the main dissertation is ambiguous.

% =============================================================================

\end{document}
