If the lambda function in 
homeViewModel.tagRecyclerViewData.observe(viewLifecycleOwner) { newData ->
            tagAdapter.submitList(newData)
            homeViewModel.updateTagRecyclerViewData(newData)
        } is called when the function fun updateTagRecyclerViewData(data : List<Tag>) {
        _tagRecyclerViewData.value = data
    } in viewModel is called, it seems like the updateTagRecyclerViewData call in lambda function is redundant. However, it seems like it is the only place where updateTagRecyclerViewData is being called in my code. where should I call it instead in my code? here is view model, adapter, and fragment. 

class HomeViewModel : ViewModel() {

    // text
    private val _text = MutableLiveData<String>().apply {
        value = "Select exercise"
    }
    val text: LiveData<String> = _text

    // card recycler
    private val _cardRecyclerViewData = MutableLiveData<List<ExerciseCard>>()
    val cardRecyclerViewData : LiveData<List<ExerciseCard>> = _cardRecyclerViewData
    fun updateCardRecyclerViewData(data : List<ExerciseCard>) {
        _cardRecyclerViewData.value = data
    }

    // tag recycler
        // this enable the submit list method
    private val _tagRecyclerViewData = MutableLiveData<List<Tag>>()
    val tagRecyclerViewData : LiveData<List<Tag>> = _tagRecyclerViewData
    fun updateTagRecyclerViewData(data : List<Tag>) {
        _tagRecyclerViewData.value = data
    }

    // muscle
    private val _muscleViewData = MutableLiveData<List<Muscle>>()
    val muscleViewData : LiveData<List<Muscle>> = _muscleViewData
    fun updateMuscleViewData(data : List<Muscle>){
        _muscleViewData.value = data
    }

}

class TagAdapter(private val context: Context, private val onItemClick: (Tag) -> Unit) :
    ListAdapter<Tag, TagAdapter.TagViewHolder>(TagDiffCallback()) {
    // Create new views (invoked by the layout manager)
    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): TagViewHolder {
        val inflater = LayoutInflater.from(parent.context)
        val view = inflater.inflate(R.layout.item_tag, parent, false)
        return TagViewHolder(view)
    }

    override fun onBindViewHolder(holder: TagViewHolder, position: Int) {
        val currentItem = getItem(position)
        holder.bind(currentItem, position)
        holder.itemView.setOnClickListener {
            onItemClick(currentItem)
        }
    }

    // TODO : manual to addItem
    fun addItem(tag: Tag) {
        val updatedList = currentList.toMutableList()
        updatedList.add(tag)
        submitList(updatedList)
        TagStorage.addTag(context, tag)
    }

    fun removeItem(position: Int) {
        val updatedList = currentList.toMutableList()
        val removedTag = updatedList.removeAt(position)
        TagStorage.removeTag(context, removedTag)
        submitList(updatedList)
    }


    fun editItem(oldTag: Tag, newTag: Tag) {
        val updatedList = currentList.toMutableList()
        val index = updatedList.indexOfFirst { it == oldTag }
        if (index != -1) {
            updatedList[index] = newTag
        }
        TagStorage.editTag(context, oldTag, newTag)
        submitList(updatedList)
    }


    inner class TagViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView)  {
        private val tagCard : CardView = itemView.findViewById(R.id.tagCard)
        private val tagName : TextView = itemView.findViewById(R.id.tagName)

        fun bind(tag : Tag, position: Int) {
            if(tag.isSelected){
                tagCard.setCardBackgroundColor(context.getColor(R.color.turquoise))
            }else{
                tagCard.setCardBackgroundColor(context.getColor(R.color.brighter_turquoise))
            }
            if (tag != Tag.ADD_TAG) {
                tagName.text = "# ${tag.name}"
                itemView.setOnLongClickListener {
                    showEditDeleteOptions(tag, position)
                    true // Consume the long click
                }
            } else tagName.text = tag.name
        }

        private fun showEditDeleteOptions(tag: Tag, position: Int) {
            val options = arrayOf("Edit", "Delete")
            AlertDialog.Builder(context)
                .setItems(options) { dialog, which ->
                    when (which) {
                        // Edit
                        0 -> {
                            val inputDialog = AlertDialog.Builder(context)
                            val inputEditText = EditText(context)
                            inputEditText.setText(tag.name)
                            inputDialog.setView(inputEditText)
                            inputDialog.setTitle(context.getString(R.string.tag_enter_name))

                            inputDialog.setPositiveButton("OK") { dialog, _ ->
                                val newTagName = inputEditText.text.toString().trim()
                                if (newTagName.isNotEmpty()) {
                                    editItem(tag, TagFactory.editTag(tag, newTagName))
                                }
                                dialog.dismiss()
                            }

                            inputDialog.setNegativeButton("Cancel") { dialog, _ ->
                                dialog.dismiss()
                            }

                            inputDialog.show()
                        }
                        // Delete
                        1 -> {
                            showDeleteWarning(position)
                        }
                    }
                    dialog.dismiss()
                }
                .show()
        }

        private fun showDeleteWarning(position: Int) {
            AlertDialog.Builder(context)
                .setTitle(context.getString(R.string.general_deletion_warning))
                .setMessage(context.getString(R.string.tag_deletion_warning))
                .setPositiveButton("Delete") { dialog, which ->
                    removeItem(position)
                }
                .setNegativeButton("Cancel") { dialog, which ->
                    dialog.dismiss()
                }
                .show()
        }
    }


}


class HomeFragment : Fragment() {

    // TODO : should I store requireContext()
    private var _binding: FragmentHomeBinding? = null

    private val binding get() = _binding!!
    private lateinit var cardAdapter: HomeCardAdapter
    private lateinit var tagAdapter: TagAdapter

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        val homeViewModel =
            ViewModelProvider(this).get(HomeViewModel::class.java)
        _binding = FragmentHomeBinding.inflate(inflater, container, false)
        val root: View = binding.root

        val addCardButtonBinding = binding.addCardButton
        addCardButtonBinding.setOnClickListener {
            val intent = Intent(activity, AddCardActivity::class.java)
            startActivity(intent)
        }

        cardAdapter = HomeCardAdapter(requireContext()) { clickedCard ->
            val intent = Intent(context, AddLogActivity::class.java).apply {
                putExtra("EXTRA_CARD_ITEM", clickedCard)
            }
            startActivity(intent)
        }
        // todo : study intent, put extra?

        tagAdapter = TagAdapter(requireContext()) { clickedTag ->
            if (clickedTag.name == Tag.ADD_TAG.name) {
                val inputDialog = AlertDialog.Builder(requireContext())
                val inputEditText = EditText(requireContext())
                inputDialog.setView(inputEditText)
                inputDialog.setTitle(getString(R.string.tag_enter_name))

                inputDialog.setPositiveButton("OK") { dialog, _ ->
                    val newTagString = inputEditText.text.toString().trim()
                    if (newTagString.isNotEmpty()) {
                        TagStorage.addTag(requireContext(), TagFactory.createTag(requireContext(), newTagString))
                        refresh()
                    }
                    dialog.dismiss()
                }

                inputDialog.setNegativeButton("Cancel") { dialog, _ ->
                    dialog.dismiss()
                }

                inputDialog.show()
            } else {
                tagAdapter.editItem(clickedTag, TagFactory.clickTag(clickedTag))
                refresh()
            }
        }


        val exerciseRecyclerViewBinding = binding.exerciseRecyclerView
        exerciseRecyclerViewBinding.layoutManager = LinearLayoutManager(requireContext())
        exerciseRecyclerViewBinding.adapter = cardAdapter
        exerciseRecyclerViewBinding.itemAnimator = DefaultItemAnimator()
        //todo : better animator
        homeViewModel.cardRecyclerViewData.observe(viewLifecycleOwner) { newData ->
            cardAdapter.submitList(newData)
            homeViewModel.updateCardRecyclerViewData(newData)
        }

        val tagRecyclerViewBinding = binding.filterBar.tagRecyclerView
        tagRecyclerViewBinding.layoutManager = LinearLayoutManager(requireContext(), LinearLayoutManager.HORIZONTAL, false)
        tagRecyclerViewBinding.adapter = tagAdapter
        tagRecyclerViewBinding.itemAnimator = DefaultItemAnimator()
        homeViewModel.tagRecyclerViewData.observe(viewLifecycleOwner) { newData ->
            tagAdapter.submitList(newData)
            homeViewModel.updateTagRecyclerViewData(newData)
        }

        return root
    }

    override fun onResume() {
        super.onResume()
        refresh()
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }

    private fun refresh() {
        val tags : MutableList<Tag> = TagStorage.loadTags(requireContext()).toMutableList()
        tags.removeAll { it == Tag.ADD_TAG }
        tags.add(Tag.ADD_TAG)
        tagAdapter.submitList(tags)
        val selectedTags = TagStorage.getSelectedTags(requireContext())
        val cards = CardStorage.getSelectedCard(requireContext(), selectedTags)
        cardAdapter.submitList(cards)
    }

    private fun getColorByStatus(status: Int): Int {
        return when (status) {
            MuscleStatus.RECOVERED -> R.color.turquoise
            MuscleStatus.RECOVERING -> R.color.grey
            MuscleStatus.NEED_EXERCISE -> R.color.cafeLatte
            else -> R.color.red
        }
    }

}
